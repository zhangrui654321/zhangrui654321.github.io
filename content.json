{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"threeNumber","date":"2025-04-11T18:58:51.760Z","updated":"2025-04-11T19:37:17.290Z","comments":true,"path":"2025/04/11/threeNumber/","link":"","permalink":"http://example.com/2025/04/11/threeNumber/","excerpt":"","text":"how to deal with ThreeNumber problemGiven an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets. Example 1: 12345678Input: nums = [-1,0,1,2,-1,-4]Output: [[-1,-1,2],[-1,0,1]]Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.The distinct triplets are [-1,0,1] and [-1,-1,2].Notice that the order of the output and the order of the triplets does not matter. MY solution:first ,we should sort the number ,then we choose one number ,and choose the first and the last number ,that means ,if the sum is too big ,then we should let the right number turn left ,if the sum is too small,the we should let the left number turn large,if the sum is suitable ,then we can add answer.code 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &gt; 0) &#123; return result; &#125; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int j = i + 1; j &lt; nums.length; j++) &#123; if (j &gt; i + 2 &amp;&amp; nums[j] == nums[j - 1] &amp;&amp; nums[j - 1] == nums[j - 2]) &#123; continue; &#125; int c = -nums[i] - nums[j]; if (set.contains(c)) &#123; result.add(Arrays.asList(nums[i], nums[j], c)); set.remove(c); &#125; else &#123; set.add(nums[j]); &#125; &#125; &#125; return result; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"two number ","date":"2025-04-06T15:15:33.586Z","updated":"2025-04-06T16:34:35.454Z","comments":true,"path":"2025/04/06/two number /","link":"","permalink":"http://example.com/2025/04/06/two%20number%20/","excerpt":"","text":"How to handle Trapping Rain Water123Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. in this problem ,for every line ,what depends on the most line height?for every height,we can find the most high right height ,and the most high left height,between this two height,we need to find the lowest one,and use the lowest one to loose height. here is the code. 1234567891011121314151617181920212223242526272829class Solution &#123; public int trap(int[] height) &#123; int sum=0; for(int i=0;i&lt;height.length;i++)&#123; if(i==0 || i==height-1)&#123; continue; &#125; int rHeight=0; int lHeight=0; for(r=i+1;r&lt;height.lenght;r++)&#123; if(height[i]&gt;rHeight)&#123; rHeight=height[i]; &#125; &#125; for(l=i-1;l&lt;height.length;l--)&#123; if(height[i]&gt;lHeight)&#123; lHeight=height[i]; &#125; &#125; int h=Maht.min(rHeight,lHeight)-height[i]; if(h&gt;0)&#123; sum+=h; &#125; &#125; return sum; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"springboot项目配置https证书","date":"2024-07-24T10:48:38.496Z","updated":"2024-07-24T10:49:06.283Z","comments":true,"path":"2024/07/24/springboot项目配置https证书/","link":"","permalink":"http://example.com/2024/07/24/springboot%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AEhttps%E8%AF%81%E4%B9%A6/","excerpt":"","text":"springboot项目配置https证书1.改写配置文件，注意，可以不写433接口123456server: port: 8080 ssl: key-store: classpath:www.xwqdzrlst.xyz.jks key-store-password: iz9n9keq key-store-type: JKS 2.在同级别配置文件下加入ssl证书 3.访问会带上https证书","categories":[],"tags":[]},{"title":"","slug":"gogs部署","date":"2024-07-14T06:40:23.548Z","updated":"2024-07-14T07:35:13.753Z","comments":true,"path":"2024/07/14/gogs部署/","link":"","permalink":"http://example.com/2024/07/14/gogs%E9%83%A8%E7%BD%B2/","excerpt":"","text":"gogs部署1.拉取镜像1docker pull gogs/gogs 2.运行docker端口12345678910111213141516171819202122232425262728293031323334353637#!/bin/bash# 设置变量CONTAINER_NAME=&quot;gogs_container&quot;HOST_DATA_DIR=&quot;/opt/xwqd/gogs/data&quot; # 请替换为您想存储Gogs数据的实际路径GOGS_PORT=3000 # Gogs Web界面端口SSH_PORT=2222 # SSH端口，用于Git操作，避免和宿主机默认的22端口冲突# 确保数据目录存在mkdir -p $HOST_DATA_DIR# 检查是否已经有一个运行中的 Gogs 容器if [ &quot;$(docker ps -q -f name=$CONTAINER_NAME)&quot; ]; then echo &quot;Stopping existing Gogs container...&quot; docker stop $CONTAINER_NAMEfi# 检查是否有一个已经停止的 Gogs 容器并删除它if [ &quot;$(docker ps -aq -f name=$CONTAINER_NAME)&quot; ]; then echo &quot;Removing existing Gogs container...&quot; docker rm $CONTAINER_NAMEfi# 运行新的 Gogs 容器echo &quot;启动新的 Gogs 容器...&quot;docker run -d --name $CONTAINER_NAME \\ -p $GOGS_PORT:3000 \\ -p $SSH_PORT:22 \\ -v $HOST_DATA_DIR:/data \\ -e &quot;USER_UID=1000&quot; \\ -e &quot;USER_GID=1000&quot; \\ gogs/gogsecho &quot;Gogs 容器启动成功。&quot;echo &quot;Web 界面可通过 http://localhost:$GOGS_PORT 访问&quot;echo &quot;数据保存在 $HOST_DATA_DIR&quot;echo &quot;请记得配置防火墙开放 $GOGS_PORT 和 $SSH_PORT 端口&quot; 3.开放防火墙端口安全组端口123456789sudo firewall-cmd --zone=public --add-port=2222/tcp --permanentsudo firewall-cmd --zone=public --add-port=3000/tcp --permanent# 重新加载防火墙配置sudo firewall-cmd --reload# 检查443端口是否已开启sudo firewall-cmd --zone=public --list-ports 4.安装gogs，配置用户名，密码 注意，这里最后的用户名密码就是你的登录用户名密码 5.将本地仓库代码上传到远程仓库,适用远程仓库是空的情况12git remote add origin http://120.78.5.19:3000/zhangrui/xwqd.gitgit push -f origin master","categories":[],"tags":[]},{"title":"","slug":"部署minio改成https注意事项","date":"2024-07-14T04:08:13.728Z","updated":"2024-07-14T04:17:24.479Z","comments":true,"path":"2024/07/14/部署minio改成https注意事项/","link":"","permalink":"http://example.com/2024/07/14/%E9%83%A8%E7%BD%B2minio%E6%94%B9%E6%88%90https%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"","text":"部署minio改成https注意事项1.如果想要htpps，ecs服务器必须开启443端口，防火墙必须开启443端口1234567891011# 开启443端口sudo firewall-cmd --zone=public --add-port=443/tcp --permanent# 重新加载防火墙配置sudo firewall-cmd --reload# 检查443端口是否已开启sudo firewall-cmd --zone=public --list-ports# 如果需要重启firewalld服务sudo systemctl restart firewalld 2.minio部署脚本 ，注意一定要加上1234567891011121314151617181920212223242526272829303132#!/bin/bash# 设置变量CONTAINER_NAME=&quot;minio_container&quot;HOST_DATA_DIR=&quot;/mnt/data&quot; # 请替换为您想要存储数据的实际路径HOST_CONFIG_DIR=&quot;/mnt/config&quot; # 请替换为您想要存储配置的实际路径# 确保数据和配置目录存在mkdir -p $HOST_DATA_DIRmkdir -p $HOST_CONFIG_DIR# 检查是否已经有一个运行中的 MinIO 容器if [ &quot;$(docker ps -q -f name=$CONTAINER_NAME)&quot; ]; then echo &quot;Stopping existing MinIO container...&quot; docker stop $CONTAINER_NAME docker rm $CONTAINER_NAMEfi# 运行一个新的 MinIO 容器echo &quot;Starting a new MinIO container...&quot;docker run -d --name $CONTAINER_NAME \\ -p 9000:9000 -p 9001:9001 \\ -e &quot;MINIO_ROOT_USER=admin&quot; \\ -e &quot;MINIO_ROOT_PASSWORD=xwqdzrlst&quot; \\ -e &quot;MINIO_HTTP_PROXY=on&quot; \\ -v $HOST_DATA_DIR:/data \\ -v $HOST_CONFIG_DIR:/root/.minio \\ minio/minio server /data --console-address &quot;:9001&quot;echo &quot;MinIO container started successfully.&quot;echo &quot;Data is persisted in $HOST_DATA_DIR&quot;echo &quot;Configuration is persisted in $HOST_CONFIG_DIR&quot; 3.注意，一定要清楚浏览器缓存","categories":[],"tags":[]},{"title":"","slug":"饿了么前端总结（上）","date":"2024-04-09T11:59:58.874Z","updated":"2024-04-09T11:58:36.106Z","comments":true,"path":"2024/04/09/饿了么前端总结（上）/","link":"","permalink":"http://example.com/2024/04/09/%E9%A5%BF%E4%BA%86%E4%B9%88%E5%89%8D%E7%AB%AF%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"饿了么前端总结（上）1.shop页面，主流程页面执行顺序为 1.create 2.computed 3.mounted 4.watch 注意，这里时compute之后有变化的属性立即watch，没有变化的时候是不执行的 1.1 create方法123456created()&#123; console.log(&quot;created&quot;) this.geohash = this.$route.query.geohash; this.shopId = this.$route.query.id; this.INIT_BUYCART(); &#125;, 获取出过来的shopid，和经纬度，初始化购物车 12345678910111213141516171819202122[INIT_BUYCART](state) &#123; let initCart = getStore(&#x27;buyCart&#x27;); if (initCart) &#123; state.cartList = JSON.parse(initCart); &#125;export const setStore = (name, content) =&gt; &#123; if (!name) return; if (typeof content !== &#x27;string&#x27;) &#123; content = JSON.stringify(content); &#125; window.localStorage.setItem(name, content);&#125;/** * 获取localStorage */export const getStore = name =&gt; &#123; if (!name) return; return window.localStorage.getItem(name);&#125; &#125;, 这里获取的时localstrage里的数据，因为是json字符串，所以要转化 1.2.直接computed赋值shopcart,然后watch12345678910111213computed:&#123;shopCart: function ()&#123; console.log(&quot;computedShopCart&quot;); return &#123;...this.cartList[this.shopId]&#125;; &#125;,&#125;watch:&#123;shopCart: function (value)&#123; console.log(&quot;watchShopCart&quot;) this.initCategoryNum(); &#125;,&#125; 这里initCategoryNum是赋值购物车，合计金额，菜单左上角相应购买数量 12345678910111213141516171819202122232425262728293031323334353637initCategoryNum()&#123; let newArr = []; let cartFoodNum = 0; this.totalPrice = 0; this.cartFoodList = []; this.menuList.forEach((item, index) =&gt; &#123; if (this.shopCart&amp;&amp;this.shopCart[item.foods[0].category_id]) &#123; let num = 0; Object.keys(this.shopCart[item.foods[0].category_id]).forEach(itemid =&gt; &#123; Object.keys(this.shopCart[item.foods[0].category_id][itemid]).forEach(foodid =&gt; &#123; let foodItem = this.shopCart[item.foods[0].category_id][itemid][foodid]; console.log(foodItem,&quot;foodItem&quot;) num += foodItem.num; if (item.type == 1) &#123; this.totalPrice += foodItem.num*foodItem.price; if (foodItem.num &gt; 0) &#123; this.cartFoodList[cartFoodNum] = &#123;&#125;; this.cartFoodList[cartFoodNum].category_id = item.foods[0].category_id; this.cartFoodList[cartFoodNum].item_id = itemid; this.cartFoodList[cartFoodNum].food_id = foodid; this.cartFoodList[cartFoodNum].num = foodItem.num; this.cartFoodList[cartFoodNum].price = foodItem.price; this.cartFoodList[cartFoodNum].name = foodItem.name; this.cartFoodList[cartFoodNum].specs = foodItem.specs; cartFoodNum ++; &#125; &#125; &#125;) &#125;) newArr[index] = num; &#125;else&#123; newArr[index] = 0; &#125; &#125;) this.totalPrice = this.totalPrice.toFixed(2); this.categoryNum = [...newArr]; &#125;, 这里有三点 1.整个购物车的结构是有 shopId,categoryId,itemId(可理解成prodItd)，foodId（SKUiD) 2.左边菜单栏有一个 cateogryId，根据cateogryiD将数据分组累计起来，如果不怕匹配，则为0，放入categoryNum 3.遍历购物车项目，将合计金额，购物车项目映射出来 这样每次进来，就显示了这个店铺中加入了购物车的数据 1.3mouted方法，主要是请求后端获取数据，渲染dom12345678910111213141516171819202122232425262728293031mounted()&#123; this.initData(); &#125;async initData()&#123; console.log(&quot;mounted&quot;) if (!this.latitude) &#123; //获取位置信息 let res = await msiteAddress(this.geohash); // 记录当前经度纬度进入vuex this.RECORD_ADDRESS(res); &#125; //获取商铺信息 this.shopDetailData = await shopDetails(this.shopId, this.latitude, this.longitude); //获取商铺食品列表 this.menuList = await foodMenu(this.shopId); //评论列表 this.ratingList = await getRatingList(this.shopId, this.ratingOffset); //商铺评论详情 this.ratingScoresData = await ratingScores(this.shopId); //评论Tag列表 this.ratingTagsList = await ratingTags(this.shopId); this.RECORD_SHOPDETAIL(this.shopDetailData) //隐藏加载动画 this.hideLoading(); &#125;,hideLoading()&#123; this.showLoading = false; &#125;, 这里hideLoading方法改变show的值，然后会执行watch方法 123456789showLoading: function (value)&#123; console.log(&quot;watchShowLoading&quot;) if (!value) &#123; this.$nextTick(() =&gt; &#123; this.getFoodListHeight(); this.initCategoryNum(); &#125;) &#125; &#125;, 初始化左右菜单的高度，然后赋值购物车，合计金额，菜单数量 getFoodListHeight方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445getFoodListHeight()&#123; const listContainer = this.$refs.menuFoodList; if (listContainer) &#123; const listArr = Array.from(listContainer.children[0].children); console.log(listArr,&quot;listArr&quot;) listArr.forEach((item, index) =&gt; &#123; this.shopListTop[index] = item.offsetTop; &#125;); console.log(this.shopListTop,&quot;shopListTop&quot;) this.listenScroll(listContainer) &#125; &#125;, //当滑动食品列表时，监听其scrollTop值来设置对应的食品列表标题的样式 listenScroll(element)&#123; this.foodScroll = new BScroll(element, &#123; probeType: 3, deceleration: 0.001, bounce: false, swipeTime: 2000, click: true, &#125;); const wrapperMenu = new BScroll(&#x27;#wrapper_menu&#x27;, &#123; click: true, &#125;); const wrapMenuHeight = this.$refs.wrapperMenu.clientHeight; console.log(wrapMenuHeight) this.foodScroll.on(&#x27;scroll&#x27;, (pos) =&gt; &#123; if (!this.$refs.wrapperMenu) &#123; return &#125; this.shopListTop.forEach((item, index) =&gt; &#123; if (this.menuIndexChange &amp;&amp; Math.abs(Math.round(pos.y)) &gt;= item) &#123; this.menuIndex = index; const menuList=this.$refs.wrapperMenu.querySelectorAll(&#x27;.activity_menu&#x27;); console.log(menuList,&quot;menuList&quot;) const el = menuList[0]; console.log(el,&quot;el&quot;) wrapperMenu.scrollToElement(el, 800, 0, -(wrapMenuHeight/2 - 50)); &#125; &#125;) &#125;) &#125;, 这里根据食品列表的高度，获取了不同菜单的offset listenScroll方法就当右边列表滑动时候，创建了一个监听事件，获取坐边菜单的index，位置，赋值menuIndex，滚动到对应的位置 实现是根据右边滚动时有个一个pos.y&gt;=item 这里的item就是offeset，因为滚动到了大于某一个offset就要赋值 2.如果是左边菜单点击，则设置右边的food列表位置，并设置左边对应的索引值 123456789chooseMenu(index)&#123; this.menuIndex = index; //menuIndexChange解决运动时listenScroll依然监听的bug this.menuIndexChange = false; this.foodScroll.scrollTo(0, -this.shopListTop[index], 400); this.foodScroll.on(&#x27;scrollEnd&#x27;, () =&gt; &#123; this.menuIndexChange = true; &#125;) &#125;, 2.buy-cart 组件页面，即显示食物列表数量的组件12345678910111213141516171819202122232425computed: &#123; ...mapState([ &#x27;cartList&#x27; ]), /** * 监听cartList变化，更新当前商铺的购物车信息shopCart，同时返回一个新的对象 */ shopCart: function ()&#123; return Object.assign(&#123;&#125;,this.cartList[this.shopId]); &#125;, //shopCart变化的时候重新计算当前商品的数量 foodNum: function ()&#123; let category_id = this.foods.category_id; let item_id = this.foods.item_id; if (this.shopCart&amp;&amp;this.shopCart[category_id]&amp;&amp;this.shopCart[category_id][item_id]) &#123; let num = 0; Object.values(this.shopCart[category_id][item_id]).forEach((item,index) =&gt; &#123; num += item.num; &#125;) return num; &#125;else &#123; return 0; &#125; &#125;, &#125;, 这里通过每个传入的food 和shopiD获取数量 即根据shopCart对应的计算food的数量 1.获取这个food的category，和itemid， 如果店铺购物车列表里有category和itemId则累加数据 12345678910111213141516171819202122removeOutCart(category_id, item_id, food_id, name, price, specs, packing_fee, sku_id, stock)&#123; if (this.foodNum &gt; 0) &#123; this.REDUCE_CART(&#123;shopid: this.shopId, category_id, item_id, food_id, name, price, specs, packing_fee, sku_id, stock&#125;); &#125; &#125;, //加入购物车，计算按钮位置。 addToCart(category_id, item_id, food_id, name, price, specs, packing_fee, sku_id, stock, event)&#123; this.ADD_CART(&#123;shopid: this.shopId, category_id, item_id, food_id, name, price, specs, packing_fee, sku_id, stock&#125;); let elLeft = event.target.getBoundingClientRect().left; let elBottom = event.target.getBoundingClientRect().bottom; this.showMoveDot.push(true); this.$emit(&#x27;showMoveDot&#x27;, this.showMoveDot, elLeft, elBottom); &#125;, //显示规格列表 showChooseList(foodScroll)&#123; this.$emit(&#x27;showChooseList&#x27;, foodScroll) &#125;, //点击多规格商品的减按钮，弹出提示 showReduceTip()&#123; this.$emit(&#x27;showReduceTip&#x27;) &#125;, 这里的event是获取对应的相对于左下角左边和右边高度，加入购物车的时候，创建小圆点自由下落 123456//显示下落圆球 showMoveDotFun(showMoveDot, elLeft, elBottom)&#123; this.showMoveDot = [...this.showMoveDot, ...showMoveDot]; this.elLeft = elLeft; this.elBottom = elBottom; &#125;, 赋值s.showMoveDo。elLeft，和elbottom 然后在html里 123456789101112&lt;transition appear @after-appear = &#x27;afterEnter&#x27; @before-appear=&quot;beforeEnter&quot; v-for=&quot;(item,index) in showMoveDot&quot; &gt; &lt;span class=&quot;move_dot&quot; v-if=&quot;item&quot;&gt; &lt;svg class=&quot;move_liner&quot;&gt; &lt;use xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; xlink:href=&quot;#cart-add&quot;&gt;&lt;/use&gt; &lt;/svg&gt; &lt;/span&gt; &lt;/transition&gt; 遍历showMoveDot 这里beforeEntry 是显示下落圆球，’afterEntry是显示购物车闪烁画面 before 这里根据left，和bottom值来显示下落轨迹 这里的addEventListener是落入指定位置的 123456789101112131415161718beforeEnter(el)&#123; el.style.transform = `translate3d(0,$&#123;37 + this.elBottom - this.windowHeight&#125;px,0)`; el.children[0].style.transform = `translate3d($&#123;this.elLeft - 30&#125;px,0,0)`; el.children[0].style.opacity = 0; &#125;, afterEnter(el)&#123; el.style.transform = `translate3d(0,0,0)`; el.children[0].style.transform = `translate3d(0,0,0)`; el.style.transition = &#x27;transform .55s cubic-bezier(0.3, -0.25, 0.7, -0.15)&#x27;; el.children[0].style.transition = &#x27;transform .55s linear&#x27;; this.showMoveDot = this.showMoveDot.map(item =&gt; false); el.children[0].style.opacity = 1; el.children[0].addEventListener(&#x27;transitionend&#x27;, () =&gt; &#123; this.listenInCart(); &#125;) el.children[0].addEventListener(&#x27;webkitAnimationEnd&#x27;, () =&gt; &#123; this.listenInCart(); 这个listenIncart在购物车闪烁动画结束时，监听，变为false 123456789101112listenInCart()&#123; if (!this.receiveInCart) &#123; console.log(&quot;listenInCart&quot;) this.receiveInCart = true; this.$refs.cartContainer.addEventListener(&#x27;animationend&#x27;, () =&gt; &#123; this.receiveInCart = false; &#125;) this.$refs.cartContainer.addEventListener(&#x27;webkitAnimationEnd&#x27;, () =&gt; &#123; this.receiveInCart = false; &#125;) &#125; &#125;, 3.样式根据选择列表显示123&lt;ul class=&quot;tag_list_ul&quot;&gt; &lt;li v-for=&quot;(item, index) in ratingTagsList&quot; :key=&quot;index&quot; :class=&quot;&#123;unsatisfied: item.unsatisfied, tagActivity: ratingTageIndex == index&#125;&quot; @click=&quot;changeTgeIndex(index, item.name)&quot;&gt;&#123;&#123;item.name&#125;&#125;(&#123;&#123;item.count&#125;&#125;)&lt;/li&gt; &lt;/ul&gt; 这里在遍历的时候获取index，然后点击方法设置this.ratingTageIndex = index; 当ratingTageIndex == index}的时候，:class=”{unsatisfied: item.unsatisfied, tagActivity: ratingTageIndex == index}这个class会生效 则显示会变动","categories":[],"tags":[]},{"title":"","slug":"mallj总结","date":"2024-04-04T05:25:23.853Z","updated":"2024-04-04T05:22:04.999Z","comments":true,"path":"2024/04/04/mallj总结/","link":"","permalink":"http://example.com/2024/04/04/mallj%E6%80%BB%E7%BB%93/","excerpt":"","text":"1.使用case和when来统计数量，比如评价1234567select count(1) AS number, count(case when evaluate =0 then 1 else null end) as praise_number, count (case when evaluate =1 then 1 else null end ) as secondary_number, count(case when evaluate =2 then 1 else null end ) as negative_number, count(case when pics is not null then 1 else null end) as pic_number from tz_prod_num where prod_id= #&#123;prodId&#125; and status=1 这段代码统计了不同评价等级的数量 2.使用if方式标签来判断是否有图片123456789101112select &lt;include refid=&quot;ProdCommDto_SQL&quot;/&gt; from tz_prod_comn pc left join tz_user u on u.user_id=pc.user_id &lt;if test=&quot;evaluate != -1 and evaluate !=3&quot;&gt; and pc.evaluate = #&#123;evaluate&#125; &lt;/if&gt; &lt;if test=&quot;evaluate==3&quot;&gt; and pc.pics is not null &lt;/if&gt; order by pc.rec_time desc 这里在evalutate等于3的时候获取图片为空的 3.判断物品是否存在，可以直接用count123456789if(productService.count(new LambdaQueryWrapper&lt;Product&gt;() .eq(Product::getProdId,prodId)) &lt;1)&#123; throw new YamiShopBindException(&quot;该商品不存在&quot;); &#125; return ServerResponseEntity.success( userCollectionService.count(new LambdaQueryWrapper&lt;UserCollection&gt;() .eq(UserCollection::getProdId,prodId) .eq(UserCollection::getUserId,SecurityUtils.getUser().getUserId()))&gt;0 ); 4.加入购物车，分两种情况，一个是购物车已经有了，一个是新加的1234567891011121314151617181920212223242526272829303132333435363738public ServerResponseEntity&lt;String&gt; addItem(@Valid @RequestBody ChangeShopCartParam param) &#123; if(param.getCount()==0) &#123; return ServerResponseEntity.showFailMsg(&quot;请输入变更数量&quot;); &#125; String userId=SecurityUtils.getUser().getUserId(); List&lt;ShopCartItemDto&gt; shopCartItems=basketService.getShopCartItems(userId); Product product=productService.getProductByProdId(param.getProdId()); Sku sku=skuService.getSkuBySkuId(param.getSkuId()); if(product.getStatus()!= 1 || sku.getStatus()!= 1) &#123; return ServerResponseEntity.showFailMsg(&quot;当前商品已下架&quot;); &#125; for (ShopCartItemDto dto : shopCartItems) &#123; if(dto.getSkuId().equals(sku.getSkuId()))&#123; Basket basket=new Basket(); basket.setUserId(userId); basket.setBasketCount(dto.getProdCount()+ param.getCount()); basket.setBasketId(dto.getBasketId()); if(basket.getBasketCount()&lt;=0)&#123; basketService.deleteShopCartItemsByBasketIds(userId,Collections.singletonList(basket.getBasketId())); return ServerResponseEntity.success(); &#125; if(sku.getStocks()&lt;basket.getBasketCount() &amp;&amp; dto.getProdCount()&gt;=0)&#123; return ServerResponseEntity.showFailMsg(&quot;库存不足&quot;); &#125; basketService.updateShopCartItem(basket); return ServerResponseEntity.success(); &#125; &#125; if(param.getCount()&lt;0)&#123; return ServerResponseEntity.showFailMsg(&quot;商品已从购物车移除&quot;); &#125; if(sku.getStocks()&lt; param.getCount() &amp;&amp; param.getCount()&gt;=0)&#123; return ServerResponseEntity.showFailMsg(&quot;库存不足&quot;); &#125; basketService.addShopCartItem(param,userId); return ServerResponseEntity.success(&quot;添加成功&quot;); &#125; 这里的数量是加减数量 这里遍历购物车，如果购物车有，则直接加减sku的数量，如果购物车没有，且减去为负数，则代表不正常，因为商品没有加过购物车，两种情况下都要判断库存 5.拿到车所有缓存12345678910111213public List&lt;ShopCartItemDto&gt; getShopCartItems(String userId) &#123; // 在这个类里面要调用这里的缓存信息，并没有使用aop，所以不使用注解 List&lt;ShopCartItemDto&gt; shopCartItemDtoList = cacheManagerUtil.getCache(&quot;ShopCartItems&quot;, userId); if (shopCartItemDtoList != null) &#123; return shopCartItemDtoList; &#125; shopCartItemDtoList = basketMapper.getShopCartItems(userId); for (ShopCartItemDto shopCartItemDto : shopCartItemDtoList) &#123; shopCartItemDto.setProductTotalAmount(Arith.mul(shopCartItemDto.getProdCount(), shopCartItemDto.getPrice())); &#125; cacheManagerUtil.putCache(&quot;ShopCartItems&quot;, userId, shopCartItemDtoList); return shopCartItemDtoList; &#125; 1.这里是先从缓存获取，如果缓存不为空，直接返回，如果缓存为空，查数据库，注意，这里有一个求和总计，每次去set值， 2.按照店铺去组装购物车 1Map&lt;Long, List&lt;ShopCartItemDto&gt;&gt; shopCartMap = shopCartItems.stream().collect(Collectors.groupingBy(ShopCartItemDto::getShopId)); 先按照店铺分组 12345678910111213141516171819List&lt;ShopCartDto&gt; shopCartDtos = Lists.newArrayList(); for (Long shopId : shopCartMap.keySet()) &#123; //获取店铺的所有商品项 List&lt;ShopCartItemDto&gt; shopCartItemDtoList = shopCartMap.get(shopId); // 构建每个店铺的购物车信息 ShopCartDto shopCart = new ShopCartDto(); //店铺信息 shopCart.setShopId(shopId); shopCart.setShopName(shopCartItemDtoList.get(0).getShopName()); applicationContext.publishEvent(new ShopCartEvent(shopCart, shopCartItemDtoList)); shopCartDtos.add(shopCart); &#125; return shopCartDtos; 这里有一个组装shopCart,店铺分多个满减活动，每个满减有多个商品 123456789101112131415@EventListener(ShopCartEvent.class) @Order(ShopCartEventOrder.DEFAULT) public void defaultShopCartEvent(ShopCartEvent event) &#123; ShopCartDto shopCart = event.getShopCartDto(); List&lt;ShopCartItemDto&gt; shopCartItemDtoList = event.getShopCartItemDtoList(); // 对数据进行组装 List&lt;ShopCartItemDiscountDto&gt; shopCartItemDiscountDtoList = Lists.newArrayList(); //每一个代表一个优惠活动 ShopCartItemDiscountDto shopCartItemDiscountDto = new ShopCartItemDiscountDto(); shopCartItemDiscountDto.setShopCartItems(shopCartItemDtoList); shopCartItemDiscountDtoList.add(shopCartItemDiscountDto); shopCart.setShopCartItemDiscounts(shopCartItemDiscountDtoList); &#125; 1Integer totalCount = shopCartItems.stream().map(ShopCartItemDto::getProdCount).reduce(0, Integer::sum); 上面这段代码可以直接计算总和 6.获取车的合计金额和件数123456789101112131415161718192021222324252627282930313233343536public ServerResponseEntity&lt;ShopCartAmountDto&gt; getTotalPay(@RequestBody List&lt;Long&gt; basketIds) &#123; List&lt;ShopCartItemDto&gt; dbShopCartItems=basketService.getShopCartItems(SecurityUtils.getUser().getUserId()); List&lt;ShopCartItemDto&gt; chooseShopCartItems=dbShopCartItems.stream().filter(item-&gt;&#123; if(basketIds.contains(item.getBasketId()))&#123; return true; &#125;else&#123; return false; &#125; &#125;).collect(Collectors.toList()); Map&lt;Long,List&lt;ShopCartItemDto&gt;&gt; shopCartMap =chooseShopCartItems.stream().collect(Collectors.groupingBy(ShopCartItemDto::getShopId)); double total=0.0; int count=0; double reduce=0.0; for (Long shopId : shopCartMap.keySet()) &#123; List&lt;ShopCartItemDto&gt; shopCartItemDtoList =shopCartMap.get(shopId); //构建每个店铺的购物车信息 ShopCartDto shopCartDto=new ShopCartDto(); shopCartDto.setShopId(shopId); applicationContext.publishEvent(new ShopCartEvent(shopCartDto,shopCartItemDtoList)); for (ShopCartItemDiscountDto discount : shopCartDto.getShopCartItemDiscounts()) &#123; for (ShopCartItemDto cartItem : discount.getShopCartItems()) &#123; count+=cartItem.getProdCount()+count; total= Arith.add(cartItem.getProductTotalAmount(),total); &#125; &#125; &#125; ShopCartAmountDto shopCartAmountDto=new ShopCartAmountDto(); shopCartAmountDto.setCount(count); shopCartAmountDto.setTotalMoney(total); shopCartAmountDto.setSubtractMoney(reduce); shopCartAmountDto.setFinalMoney(Arith.sub(shopCartAmountDto.getTotalMoney(),shopCartAmountDto.getSubtractMoney())); return ServerResponseEntity.success(shopCartAmountDto); &#125; 这个是车的选中方法，每当选中方法改变时，合计金额也改变，先过滤掉车里的没有选中的，然后根据店铺分组，每组中组装每个店铺的满减项目，然后统计合计金额，合计件数，这里的reduce刚好是每个满减项目的减去金额 8.生成订单方法1.先从缓存获取结算订单 2.设置备注到结算订单中 3.提交订单，发布监听模式。 4.删除四个缓存，删除sku，prod缓存，如果是购物车项目，也删除购物车项目缓存，删除结算订单缓存 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public ServerResponseEntity&lt;OrderNumbersDto&gt; submitOrders(@Valid @RequestBody SubmitOrderParam submitOrderParam) &#123; String userId = SecurityUtils.getUser().getUserId(); ShopCartOrderMergerDto mergerOrder = orderService.getConfirmOrderCache(userId); if (mergerOrder == null) &#123; throw new YamiShopBindException(&quot;订单已过期，请重新下单&quot;); &#125; List&lt;OrderShopParam&gt; orderShopParams = submitOrderParam.getOrderShopParam(); List&lt;ShopCartOrderDto&gt; shopCartOrders = mergerOrder.getShopCartOrders(); // 设置备注 if (CollectionUtil.isNotEmpty(orderShopParams)) &#123; for (ShopCartOrderDto shopCartOrder : shopCartOrders) &#123; for (OrderShopParam orderShopParam : orderShopParams) &#123; if (Objects.equals(shopCartOrder.getShopId(), orderShopParam.getShopId())) &#123; shopCartOrder.setRemarks(orderShopParam.getRemarks()); &#125; &#125; &#125; &#125; List&lt;Order&gt; orders = orderService.submit(userId,mergerOrder); StringBuilder orderNumbers = new StringBuilder(); for (Order order : orders) &#123; orderNumbers.append(order.getOrderNumber()).append(&quot;,&quot;); &#125; orderNumbers.deleteCharAt(orderNumbers.length() - 1); boolean isShopCartOrder = false; // 移除缓存 for (ShopCartOrderDto shopCartOrder : shopCartOrders) &#123; for (ShopCartItemDiscountDto shopCartItemDiscount : shopCartOrder.getShopCartItemDiscounts()) &#123; for (ShopCartItemDto shopCartItem : shopCartItemDiscount.getShopCartItems()) &#123; Long basketId = shopCartItem.getBasketId(); if (basketId != null &amp;&amp; basketId != 0) &#123; isShopCartOrder = true; &#125; skuService.removeSkuCacheBySkuId(shopCartItem.getSkuId(),shopCartItem.getProdId()); productService.removeProductCacheByProdId(shopCartItem.getProdId()); &#125; &#125; &#125; // 购物车提交订单时(即有购物车ID时) if (isShopCartOrder) &#123; basketService.removeShopCartItemsCacheByUserId(userId); &#125; orderService.removeConfirmOrderCache(userId); return ServerResponseEntity.success(new OrderNumbersDto(orderNumbers.toString())); &#125; 这个方法巧妙点在于判断购物车项目，如果有一个购物车项目的basketId不是空，则代表了是购物车下单的 9。提交订单事件1.先根据缓存结算订单组装orderList 2.批量保存orderList，orderListItem 123456789101112public List&lt;Order&gt; submit(String userId, ShopCartOrderMergerDto mergerOrder) &#123; List&lt;Order&gt; orderList = new ArrayList&lt;&gt;(); // 通过事务提交订单 eventPublisher.publishEvent(new SubmitOrderEvent(mergerOrder, orderList)); // 插入订单 saveBatch(orderList); List&lt;OrderItem&gt; orderItems = orderList.stream().flatMap(order -&gt; order.getOrderItems().stream()).collect(Collectors.toList()); // 插入订单项，返回主键 orderItemMapper.insertBatch(orderItems); return orderList; &#125; 10.组装订单的事件1.新建一个空的skuMap，prodMap，basktId 2.每个店铺生成一个订单，保存一个结算单，同时组装skuMap，prodMap，basktId，orderiTEM,orderList五个东西 3.更新库存，删除购物车，包括sku，prod库存， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public void defaultSubmitOrderListener(SubmitOrderEvent event) &#123; Date now = new Date(); String userId = SecurityUtils.getUser().getUserId(); ShopCartOrderMergerDto mergerOrder = event.getMergerOrder(); // 订单商品参数 List&lt;ShopCartOrderDto&gt; shopCartOrders = mergerOrder.getShopCartOrders(); List&lt;Long&gt; basketIds = new ArrayList&lt;&gt;(); // 商品skuId为key 需要更新的sku为value的map Map&lt;Long, Sku&gt; skuStocksMap = new HashMap&lt;&gt;(16); // 商品productId为key 需要更新的product为value的map Map&lt;Long, Product&gt; prodStocksMap = new HashMap&lt;&gt;(16); // 把订单地址保存到数据库 UserAddrOrder userAddrOrder = BeanUtil.copyProperties(mergerOrder.getUserAddr(), UserAddrOrder.class); if (userAddrOrder == null) &#123; throw new YamiShopBindException(&quot;请填写收货地址&quot;); &#125; userAddrOrder.setUserId(userId); userAddrOrder.setCreateTime(now); userAddrOrderService.save(userAddrOrder); // 订单地址id Long addrOrderId = userAddrOrder.getAddrOrderId(); // 每个店铺生成一个订单 for (ShopCartOrderDto shopCartOrderDto : shopCartOrders) &#123; createOrder(event, now, userId, basketIds, skuStocksMap, prodStocksMap, addrOrderId, shopCartOrderDto); &#125; // 删除购物车的商品信息 if (!basketIds.isEmpty()) &#123; basketMapper.deleteShopCartItemsByBasketIds(userId, basketIds); &#125; // 更新sku库存 skuStocksMap.forEach((key, sku) -&gt; &#123; if (skuMapper.updateStocks(sku) == 0) &#123; skuService.removeSkuCacheBySkuId(key, sku.getProdId()); throw new YamiShopBindException(&quot;商品：[&quot; + sku.getProdName() + &quot;]库存不足&quot;); &#125; &#125;); // 更新商品库存 prodStocksMap.forEach((prodId, prod) -&gt; &#123; if (productMapper.updateStocks(prod) == 0) &#123; productService.removeProductCacheByProdId(prodId); throw new YamiShopBindException(&quot;商品：[&quot; + prod.getProdName() + &quot;]库存不足&quot;); &#125; &#125;); &#125; 总结点 1.可以通过初始化一个map。在多层循环里增加累计map 2.map可以通过foreach遍历 11.校验，并组装更新的库存方法123456789101112131415161718192021222324252627282930313233private Product checkAndGetProd(Long prodId, ShopCartItemDto shopCartItem, Map&lt;Long, Product&gt; prodStocksMap) &#123; Product product = productService.getProductByProdId(prodId); if (product == null) &#123; throw new YamiShopBindException(&quot;购物车包含无法识别的商品&quot;); &#125; if (product.getStatus() != 1) &#123; throw new YamiShopBindException(&quot;商品[&quot; + product.getProdName() + &quot;]已下架&quot;); &#125; // 商品需要改变的库存 Product mapProduct = prodStocksMap.get(prodId); if (mapProduct == null) &#123; mapProduct = new Product(); mapProduct.setTotalStocks(0); mapProduct.setProdId(prodId); mapProduct.setProdName(product.getProdName()); &#125; if (product.getTotalStocks() != -1) &#123; mapProduct.setTotalStocks(mapProduct.getTotalStocks() + shopCartItem.getProdCount()); prodStocksMap.put(product.getProdId(), mapProduct); &#125; // -1为无限库存 if (product.getTotalStocks() != -1 &amp;&amp; mapProduct.getTotalStocks() &gt; product.getTotalStocks()) &#123; throw new YamiShopBindException(&quot;商品：[&quot; + product.getProdName() + &quot;]库存不足&quot;); &#125; return product; &#125; 这里如果produt如果为空，则新建一个prod，如果有库存校验，则累计库存，超过库存报错，这里相当于根据prod分组，累计prod数量，并做库存更新。","categories":[],"tags":[]},{"title":"","slug":"获取sku页面前端总结记录","date":"2024-03-26T12:26:14.808Z","updated":"2024-03-26T12:25:15.195Z","comments":true,"path":"2024/03/26/获取sku页面前端总结记录/","link":"","permalink":"http://example.com/2024/03/26/%E8%8E%B7%E5%8F%96sku%E9%A1%B5%E9%9D%A2%E5%89%8D%E7%AB%AF%E6%80%BB%E7%BB%93%E8%AE%B0%E5%BD%95/","excerpt":"","text":"获取sku页面前端总结记录1.vue页面的执行顺序1create-&gt;compute-&gt;watch 注意，这里compute先执行完对应的值再compute 场景案例，比如想先根据productId 初始化页面信息 12345computed&#123; productId()&#123; return this.value.productId; &#125;,&#125; 先获取，然后再watch 12345678watch:&#123; productId:function (newValue) &#123; if(!this.isEdit)return; if(this.hasEditCreated)return; if(newValue===undefined||newValue==null||newValue===0)return; this.handleEditCreated(); &#125; &#125;, 下面用到了 123456handleEditCreated()&#123; if(this.value.productAttributeCategoryId!=null)&#123; this.handleProductAttrChange(this.value.productAttributeCategoryId); &#125; this.hasEditCreated=true; &#125; 2.初始化属性值总结这里的业务是分为两种 1.可以生成sku的，通过sku里的spdata的json来获取组装的属性 2.不可以生成sku的，只是单一的属性，则通过attrValueliST来获取值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546handleProductAttrChange(value)&#123; this.getProductAttrList(0, value); this.getProductAttrList(1, value); &#125;etProductAttrList(type,cid)&#123; let param= &#123;pageNum:1,pageSize:100,cid :cid&#125;; fetchProductAttrList(cid,param).then(result =&gt; &#123; let list=result.list; if(type===0)&#123; this.selectProductAttr=[]; for(let i=0;i&lt;list.length;i++)&#123; let options=[]; let values=[]; if(this.isEdit)&#123; if(list[i].handAddStatus===1)&#123; options =this.getEditAttrOptions(list[i].id); &#125; values =this.getEditAttribute(i); &#125; this.selectProductAttr.push(&#123; id:list[i].id, name: list[i].name, handleAddStatus: list[i].handleAddStatus, inputList:list[i].inputList, values:values, options:options &#125;) &#125; &#125;else&#123; this.selectProductParam=[]; for (let i = 0; i &lt; list.length.length; i++) &#123; let value =null; if(this.isEdit)&#123; value =this.getEditParamValue(list[i].id); &#125; this.selectProductParam.push(&#123; id: list[i].id, name: list[i].name, value: value, inputType: list[i].inputType, inputList: list[i].inputList &#125;) &#125; &#125; &#125;) &#125;, 这里获取选中的属性值1234567891011121314151617181920212223242526272829getEditAttribute(index)&#123; let values= new Set(); if(index ===0)&#123; for (let i = 0; i &lt; this.value.skuStockList.length; i++) &#123; let sku =this.value.skuStockList[i]; let spData=JSON.parse(sku.spData); if(spData!=null &amp;&amp; spData &gt;=1)&#123; values.add(spData[0].value); &#125; &#125; &#125;else if(index ===1)&#123; for(let i = 0; i &lt; this.value.skuStockList.length;i++)&#123; let sku =this.value.skuStockList[i]; let spData =JSON.parse(sku.spData); if(spData!=null &amp;&amp; spData &gt;=1)&#123; values.add(spData[1].value); &#125; &#125; &#125;else&#123; for(let i = 0; i &lt; this.value.skuStockList.length;i++)&#123; let sku =this.value.skuStockList[i]; let spData =JSON.parse(sku.spData); if(spData!=null &amp;&amp; spData &gt;=1)&#123; values.add(spData[2].value); &#125; &#125; &#125; return Array.from(values); &#125;, 这里通过set去掉重复，把每层的value值填入进去，注意，这里的getEditAttribute返回值可以不定义，但是仍然有效。 3.根据value值返填sku的数据12345678910111213141516171819202122232425262728293031323334353637383940refreshProductSkuList()&#123; this.value.skuStockList=[]; let skuList=this.value.skuStockList; if(this.selectProductAttr.length===1)&#123; let arr=this.selectProductAttr[0]; for (let i = 0; i &lt; arr.values.length; i++) &#123; skuList.push(&#123; spData: JSON.stringify([&#123;key:arr.name,value :arr.values[i]&#125;]) &#125;) &#125; &#125; else if(this.selectProductAttr.length==2)&#123; let arr0=this.selectProductAttr[0]; let arr1=this.selectProductAttr[1]; for (let i = 0; i &lt; arr0.values.length; i++) &#123; for (let j = 0; j &lt; arr1.values.length; j++) &#123; let spData=[]; spData.push(&#123;key:arr0.name,value:arr0.values[i]&#125;) spData.push(&#123;key:arr1.name,value:arr1.values[j]&#125;) skuList.push(&#123;spData: JSON.stringify(spData)&#125;); &#125; &#125; &#125;else if(this.selectProductAttr.length==3)&#123; let arr0=this.selectProductAttr[0]; let arr1=this.selectProductAttr[1]; let arr2=this.selectProductAttr[2]; for (let i = 0; i &lt; arr0.values.length; i++) &#123; for (let j = 0; j &lt; arr1.length.length; j++) &#123; for (let k = 0; k &lt; arr2.values.length; k++) &#123; let spData=[]; spData.push(&#123;key:arr0.name,value:arr0.values[i]&#125;); spData.push(&#123;key:arr1.name,value:arr1.values[j]&#125;); spData.push(&#123;key:arr2.name,value:arr2.values[k]&#125;); &#125; &#125; &#125; &#125; &#125;, 这里把可以选择的属性作为笛卡尔积，然后组合，比如第一个属性2个值，第二个3个，则一共有2*3个sku 这里将属性列表string化，通过Json。stringify 4.computed下的设值方法,完成前后端数据转换，常用于图片数组这里前端页面组件时图片数组，后端传来的是1，2，3 这种字符串 要互相进行转化，get是将字符转为数组，前端回显 set是将数组转为字符，给后端设值 1234567891011121314151617181920212223242526272829303132selectProductPics:&#123; get:function ()&#123; let pics=[]; if(this.value.pic===undefined || this.value.pic==null || this.value.pic===&#x27;&#x27;)&#123; return pics; &#125; pics.push(this.value.pic); if(this.value.albumPics===undefined || this.value.albumPics ==null || this.value.albumPics==&#x27;&#x27;)&#123; return pics; &#125; let albumPics=this.value.albumPics.split(&quot;,&quot;); for(let i=0;i&lt;albumPics.length;i++)&#123; pics.push(albumPics[i]); &#125; return pics; &#125;, set:function (newValue)&#123; if(newValue===null || newValue===undefined)&#123; this.value.pic=null; this.value.albumPics=null; &#125;else&#123; this.value.pic=newValue[0]; this.value.albumPics=&#x27;&#x27;; if(newValue.length&gt;1)&#123; for(let i=1;i&lt;newValue.length;i++)&#123; this.value.albumPics+=&#x27;,&#x27;; &#125; &#125; &#125; &#125;, &#125; 5.如何将sku的属性值展开123456789&lt;el-table-column v-for=&quot;(item,index) in selectProductAttr&quot; :label=&quot;item.name&quot; :key=&quot;item.id&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123;getProductSkuSp(scope.row,index)&#125;&#125; &lt;/template&gt; &lt;/el-table-column&gt; 1234567getProductSkuSp(row, index)&#123; let spData =JSON.parse(row.spData); if(spData!=null &amp;&amp; index&lt;spData.length)&#123; return spData[index].value; &#125; return null; &#125;, 在table里面，用v-for将属性遍历，这里通过getProductSkuSp方法拿到对应的值 注意这里先将spData解析出来，然后通过索引去获取到值 6.结束方法12345handleNext()&#123; this.mergeProductValue(); this.mergeProductAttrPics(); this.$emit(&#x27;nextStep&#x27;) &#125;, 1.合并商品属性，将可以增加的属性也合并一起，将option数组转化为string 2.合并商品图片，根据第一个属性值，将图片设置到sku里 3.父组件事件 12345678910111213141516171819mergeProductValue()&#123; this.value.productAttributeValueList=[]; for (let i = 0; i &lt; this.selectProductAttr.length; i++) &#123; let arr=this.selectProductAttr[i]; if(arr.handleAddStatus ===1 &amp;&amp; arr.options!=null &amp;&amp; arr.options.length&gt;0)&#123; this.value.productAttributeValueList.push(&#123; productAttributeId: arr.id, value: this.getOptionStr(arr.options) &#125;) &#125; &#125; for (let i = 0; i &lt; this.selectProductParam.length; i++) &#123; let param=this.selectProductParam[i]; this.value.productAttributeValueList.push(&#123; productAttributeId: param.id, value: param.value &#125;); &#125; &#125;, 12345678910mergeProductAttrPics()&#123; for (let i = 0; i &lt;this.value.selectProductAttrPics.length; i++) &#123; for (let j = 0; j &lt; this.value.skuStockList; j++) &#123; let spData=JSON.parse(this.value.skuStockList[j]); if(spData[0].value ===this.selectProductAttrPics[i].name)&#123; this.value.skuStockList[j].pic=this.value.selectProductAttrPics[i].pic; &#125; &#125; &#125; &#125;, 7.属性值的前端显示123456789101112131415161718192021&lt;el-card shadow=&quot;never&quot; class=&quot;cardBg&quot;&gt; &lt;div v-for=&quot;(productAttr,idx) in selectProductAttr&quot;&gt; &#123;&#123;productAttr.name&#125;&#125;： &lt;el-checkbox-group v-if=&quot;productAttr.handAddStatus===0&quot; v-model=&quot;selectProductAttr[idx].values&quot;&gt; &lt;el-checkbox v-for=&quot;item in getInputListArr(productAttr.inputList)&quot; :label=&quot;item&quot; :key=&quot;item&quot; class=&quot;littleMarginLeft&quot;&gt;&lt;/el-checkbox&gt; &lt;/el-checkbox-group&gt; &lt;div v-else&gt; &lt;el-checkbox-group v-model=&quot;selectProductAttr[idx].values&quot;&gt; &lt;div v-for=&quot;(item,index) in selectProductAttr[idx].options&quot; style=&quot;display: inline-block&quot; class=&quot;littleMarginLeft&quot;&gt; &lt;el-checkbox :label=&quot;item&quot; :key=&quot;item&quot;&gt;&lt;/el-checkbox&gt; &lt;el-button type=&quot;text&quot; class=&quot;littleMarginLeft&quot; @click=&quot;handleRemoveProductAttrValue(idx,index)&quot;&gt;删除 &lt;/el-button&gt; &lt;/div&gt; &lt;/el-checkbox-group&gt; &lt;el-input v-model=&quot;addProductAttrValue&quot; style=&quot;width: 160px;margin-left: 10px&quot; clearable&gt;&lt;/el-input&gt; &lt;el-button class=&quot;littleMarginLeft&quot; @click=&quot;handleAddProductAttrValue(idx)&quot;&gt;增加&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/el-card&gt; 这里遍历selectProductAttr ，分两种情况 1.不是增加属性，直接列出，通过v-if判断 2.是增加属性 v-else 这里技巧是遍历时获取idx，这样在新增和修改的时候就方便操作了删除 123handleRemove(idx,index)&#123; this.selectProductAttr[idx].options.splice(index,1)&#125; 新增 在data里绑定了一个addProductAttrValue值，新增后面置为空 注意，这里可以通过indexof判断是否存在，避免重复 123456789101112131415161718192021handleAddProductAttrValue(idx) &#123; let options = this.selectProductAttr[idx].options; if (this.addProductAttrValue == null || this.addProductAttrValue == &#x27;&#x27;) &#123; this.$message(&#123; message: &#x27;属性值不能为空&#x27;, type: &#x27;warning&#x27;, duration: 1000 &#125;); return &#125; if (options.indexOf(this.addProductAttrValue) !== -1) &#123; this.$message(&#123; message: &#x27;属性值不能重复&#x27;, type: &#x27;warning&#x27;, duration: 1000 &#125;); return; &#125; this.selectProductAttr[idx].options.push(this.addProductAttrValue); this.addProductAttrValue = null; &#125;,","categories":[],"tags":[]},{"title":"","slug":"mall 项目的后端总结，技巧篇之一","date":"2024-03-15T14:19:25.856Z","updated":"2024-03-15T14:33:06.557Z","comments":true,"path":"2024/03/15/mall 项目的后端总结，技巧篇之一/","link":"","permalink":"http://example.com/2024/03/15/mall%20%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%90%8E%E7%AB%AF%E6%80%BB%E7%BB%93%EF%BC%8C%E6%8A%80%E5%B7%A7%E7%AF%87%E4%B9%8B%E4%B8%80/","excerpt":"","text":"mall 项目的后端总结，技巧篇之一1.可以用sql过滤需要的数据，比如查出一段是推荐的商品12345678910SELECT p.* FROM sms_home_new_product hp LEFT JOIN pms_product p ON hp.product_id = p.id WHERE hp.recommend_status = 1 AND p.publish_status = 1 ORDER BY hp.sort DESC LIMIT #&#123;offset&#125;, #&#123;limit&#125;; 这里的offset代表偏离几个开始 2.购物车到结算时，时通过购物车id作为过滤，筛选出已经选中的购物车12345678910111213@Override public List&lt;CartPromotionItem&gt; listPromotion(Long memberId, List&lt;Long&gt; cartIds) &#123; List&lt;OmsCartItem&gt; cartItemList = list(memberId); if(CollUtil.isNotEmpty(cartIds))&#123; cartItemList = cartItemList.stream().filter(item-&gt;cartIds.contains(item.getId())).collect(Collectors.toList()); &#125; List&lt;CartPromotionItem&gt; cartPromotionItemList = new ArrayList&lt;&gt;(); if(!CollectionUtils.isEmpty(cartItemList))&#123; cartPromotionItemList = promotionService.calcCartPromotion(cartItemList); &#125; return cartPromotionItemList; &#125; 3.下面这段代码的逻辑就是根据productId分组，1.遍历购物车中的product分组 2.根据每个product分组的优惠规则，得到每个的优惠规则 3.比如满减，将product的满减规则排序，然后&gt;=当前规则数量的就是该规则，如果没有则不使用规则，单独一个方法处理 4.遍历当前分组的item，将优惠金额设置进去 12345678910111213141516171819202122232425262728293031323334353637383940@Override public List&lt;CartPromotionItem&gt; calcCartPromotion(List&lt;OmsCartItem&gt; cartItemList) &#123; //1.先根据productId对CartItem进行分组，以spu为单位进行计算优惠 Map&lt;Long, List&lt;OmsCartItem&gt;&gt; productCartMap = groupCartItemBySpu(cartItemList); //2.查询所有商品的优惠相关信息 List&lt;PromotionProduct&gt; promotionProductList = getPromotionProductList(cartItemList); //3.根据商品促销类型计算商品促销优惠价格 List&lt;CartPromotionItem&gt; cartPromotionItemList = new ArrayList&lt;&gt;(); for (Map.Entry&lt;Long, List&lt;OmsCartItem&gt;&gt; entry : productCartMap.entrySet()) &#123; Long productId = entry.getKey(); PromotionProduct promotionProduct = getPromotionProductById(productId, promotionProductList); List&lt;OmsCartItem&gt; itemList = entry.getValue(); Integer promotionType = promotionProduct.getPromotionType(); if (promotionType == 3) &#123; //打折优惠 int count = getCartItemCount(itemList); PmsProductLadder ladder = getProductLadder(count, promotionProduct.getProductLadderList()); if(ladder!=null)&#123; for (OmsCartItem item : itemList) &#123; CartPromotionItem cartPromotionItem = new CartPromotionItem(); BeanUtils.copyProperties(item,cartPromotionItem); String message = getLadderPromotionMessage(ladder); cartPromotionItem.setPromotionMessage(message); //商品原价-折扣*商品原价 PmsSkuStock skuStock = getOriginalPrice(promotionProduct,item.getProductSkuId()); BigDecimal originalPrice = skuStock.getPrice(); BigDecimal reduceAmount = originalPrice.subtract(ladder.getDiscount().multiply(originalPrice)); cartPromotionItem.setReduceAmount(reduceAmount); cartPromotionItem.setRealStock(skuStock.getStock()-skuStock.getLockStock()); cartPromotionItem.setIntegration(promotionProduct.getGiftPoint()); cartPromotionItem.setGrowth(promotionProduct.getGiftGrowth()); cartPromotionItemList.add(cartPromotionItem); &#125; &#125;else&#123; handleNoReduce(cartPromotionItemList,itemList,promotionProduct); &#125; &#125; &#125; return cartPromotionItemList; &#125; 4.这里附录有个注意，排序获取后比较大小获取分组，值得学习 123456789101112131415private PmsProductLadder getProductLadder(int count, List&lt;PmsProductLadder&gt; productLadderList) &#123; //按数量从大到小排序 productLadderList.sort(new Comparator&lt;PmsProductLadder&gt;() &#123; @Override public int compare(PmsProductLadder o1, PmsProductLadder o2) &#123; return o2.getCount() - o1.getCount(); &#125; &#125;); for (PmsProductLadder productLadder : productLadderList) &#123; if (count &gt;= productLadder.getCount()) &#123; return productLadder; &#125; &#125; return null; &#125; 4.根据数据库关系 获取优惠卷 ，指的是获取某个product的1.普通优惠卷，2.指定分类优惠卷 3.指定商品优惠卷 这里通过sms_coupon_product_category_relation和优惠卷的关系表过滤了固定的关系和产品分类 12345678910111213141516171819202122232425SELECT * FROM sms_coupon WHERE use_type = 0 AND start_time &amp;lt; NOW() AND end_time &amp;gt; NOW() UNION ( SELECT c.* FROM sms_coupon_product_category_relation cpc LEFT JOIN sms_coupon c ON cpc.coupon_id = c.id WHERE c.use_type = 1 AND c.start_time &amp;lt; NOW() AND c.end_time &amp;gt; NOW() AND cpc.product_category_id = #&#123;productCategoryId&#125; ) UNION ( SELECT c.* FROM sms_coupon_product_relation cp LEFT JOIN sms_coupon c ON cp.coupon_id = c.id WHERE c.use_type = 2 AND c.start_time &amp;lt; NOW() AND c.end_time &amp;gt; NOW() AND cp.product_id = #&#123;productId&#125; ) 5.根据优惠后的购物车项目获取优惠卷这里先初始化两个list，一个是正确，一个无用的优惠卷list 遍历可用的优惠卷有三种情况 1.是通用的，则比较单据金额，时间是否在范围 2.如果是固定分类，则算出固定分类下的商品金额，比较该金额和最小金额大小，时间是否在范围 3.如果固定商品，同理2 最后根据需要的优惠卷返回正确还是错误的优惠卷集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Override public List&lt;SmsCouponHistoryDetail&gt; listCart(List&lt;CartPromotionItem&gt; cartItemList, Integer type) &#123; UmsMember currentMember = memberService.getCurrentMember(); Date now = new Date(); //获取该用户所有优惠券 List&lt;SmsCouponHistoryDetail&gt; allList = couponHistoryDao.getDetailList(currentMember.getId()); //根据优惠券使用类型来判断优惠券是否可用 List&lt;SmsCouponHistoryDetail&gt; enableList = new ArrayList&lt;&gt;(); List&lt;SmsCouponHistoryDetail&gt; disableList = new ArrayList&lt;&gt;(); for (SmsCouponHistoryDetail couponHistoryDetail : allList) &#123; Integer useType = couponHistoryDetail.getCoupon().getUseType(); BigDecimal minPoint = couponHistoryDetail.getCoupon().getMinPoint(); Date endTime = couponHistoryDetail.getCoupon().getEndTime(); if(useType.equals(0))&#123; //0-&gt;全场通用 //判断是否满足优惠起点 //计算购物车商品的总价 BigDecimal totalAmount = calcTotalAmount(cartItemList); if(now.before(endTime)&amp;&amp;totalAmount.subtract(minPoint).intValue()&gt;=0)&#123; enableList.add(couponHistoryDetail); &#125;else&#123; disableList.add(couponHistoryDetail); &#125; &#125;else if(useType.equals(1))&#123; //1-&gt;指定分类 //计算指定分类商品的总价 List&lt;Long&gt; productCategoryIds = new ArrayList&lt;&gt;(); for (SmsCouponProductCategoryRelation categoryRelation : couponHistoryDetail.getCategoryRelationList()) &#123; productCategoryIds.add(categoryRelation.getProductCategoryId()); &#125; BigDecimal totalAmount = calcTotalAmountByproductCategoryId(cartItemList,productCategoryIds); if(now.before(endTime)&amp;&amp;totalAmount.intValue()&gt;0&amp;&amp;totalAmount.subtract(minPoint).intValue()&gt;=0)&#123; enableList.add(couponHistoryDetail); &#125;else&#123; disableList.add(couponHistoryDetail); &#125; &#125;else if(useType.equals(2))&#123; //2-&gt;指定商品 //计算指定商品的总价 List&lt;Long&gt; productIds = new ArrayList&lt;&gt;(); for (SmsCouponProductRelation productRelation : couponHistoryDetail.getProductRelationList()) &#123; productIds.add(productRelation.getProductId()); &#125; BigDecimal totalAmount = calcTotalAmountByProductId(cartItemList,productIds); if(now.before(endTime)&amp;&amp;totalAmount.intValue()&gt;0&amp;&amp;totalAmount.subtract(minPoint).intValue()&gt;=0)&#123; enableList.add(couponHistoryDetail); &#125;else&#123; disableList.add(couponHistoryDetail); &#125; &#125; &#125; if(type.equals(1))&#123; return enableList; &#125;else&#123; return disableList; &#125; &#125; 6.对下单商品的优惠卷进行处理123456789101112131415private void handleCouponAmount(List&lt;OmsOrderItem&gt; orderItemList, SmsCouponHistoryDetail couponHistoryDetail) &#123; SmsCoupon coupon = couponHistoryDetail.getCoupon(); if (coupon.getUseType().equals(0)) &#123; //全场通用 calcPerCouponAmount(orderItemList, coupon); &#125; else if (coupon.getUseType().equals(1)) &#123; //指定分类 List&lt;OmsOrderItem&gt; couponOrderItemList = getCouponOrderItemByRelation(couponHistoryDetail, orderItemList, 0); calcPerCouponAmount(couponOrderItemList, coupon); &#125; else if (coupon.getUseType().equals(2)) &#123; //指定商品 List&lt;OmsOrderItem&gt; couponOrderItemList = getCouponOrderItemByRelation(couponHistoryDetail, orderItemList, 1); calcPerCouponAmount(couponOrderItemList, coupon); &#125; &#125; 这里分了三种情况 1.通用优惠卷，则所有订单明细做金额折扣处理 2.指定分类，则获取指定分类的订单项目，做折扣处理，其他不做处理 3.指定商品同理 6.获取积分抵扣12345678910111213141516171819202122232425private BigDecimal getUseIntegrationAmount(Integer useIntegration, BigDecimal totalAmount, UmsMember currentMember, boolean hasCoupon) &#123; BigDecimal zeroAmount = new BigDecimal(0); //判断用户是否有这么多积分 if (useIntegration.compareTo(currentMember.getIntegration()) &gt; 0) &#123; return zeroAmount; &#125; //根据积分使用规则判断是否可用 //是否可与优惠券共用 UmsIntegrationConsumeSetting integrationConsumeSetting = integrationConsumeSettingMapper.selectByPrimaryKey(1L); if (hasCoupon &amp;&amp; integrationConsumeSetting.getCouponStatus().equals(0)) &#123; //不可与优惠券共用 return zeroAmount; &#125; //是否达到最低使用积分门槛 if (useIntegration.compareTo(integrationConsumeSetting.getUseUnit()) &lt; 0) &#123; return zeroAmount; &#125; //是否超过订单抵用最高百分比 BigDecimal integrationAmount = new BigDecimal(useIntegration).divide(new BigDecimal(integrationConsumeSetting.getUseUnit()), 2, RoundingMode.HALF_EVEN); BigDecimal maxPercent = new BigDecimal(integrationConsumeSetting.getMaxPercentPerOrder()).divide(new BigDecimal(100), 2, RoundingMode.HALF_EVEN); if (integrationAmount.compareTo(totalAmount.multiply(maxPercent)) &gt; 0) &#123; return zeroAmount; &#125; return integrationAmount; &#125; 1.这里默认是0，如果不符合规则，则直接返回，如果都没有不符合，则返回填入的积分 这个设计方式值得学习 7，更新订单使用状态123456789101112131415private void updateCouponStatus(Long couponId, Long memberId, Integer useStatus) &#123; if (couponId == null) return; //查询第一张优惠券 SmsCouponHistoryExample example = new SmsCouponHistoryExample(); example.createCriteria().andMemberIdEqualTo(memberId) .andCouponIdEqualTo(couponId).andUseStatusEqualTo(useStatus == 0 ? 1 : 0); List&lt;SmsCouponHistory&gt; couponHistoryList = couponHistoryMapper.selectByExample(example); if (!CollectionUtils.isEmpty(couponHistoryList)) &#123; SmsCouponHistory couponHistory = couponHistoryList.get(0); couponHistory.setUseTime(new Date()); couponHistory.setUseStatus(useStatus); couponHistoryMapper.updateByPrimaryKeySelective(couponHistory); &#125; &#125;// useStatus 0-&gt;未使用；1-&gt;已使用 这里的usestatus 就是订单的使用状态 技巧是如果更新为0，则查找的是状态1，如果更新是1，则查找的是0 example.createCriteria().andMemberIdEqualTo(memberId) .andCouponIdEqualTo(couponId).andUseStatusEqualTo(useStatus == 0 ? 1 : 0);","categories":[],"tags":[]},{"title":"","slug":"optional的使用总结","date":"2024-03-14T13:52:43.587Z","updated":"2024-03-14T13:52:43.588Z","comments":true,"path":"2024/03/14/optional的使用总结/","link":"","permalink":"http://example.com/2024/03/14/optional%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"optional的使用总结1..ifPresent避免使用空指针这里是在ifpresent中如果不为空则执行各种程序123456789101112public static void main(String[] args) &#123; HashMap&lt;Object, Object&gt; objectObjectHashMap = new HashMap&lt;&gt;(); objectObjectHashMap.put(&quot;name&quot;, &quot;kawai&quot;); objectObjectHashMap.put(&quot;age&quot;, 18); Person a = new Person(); //TODO 使用内部的ifPresent避免了空指针异常 Optional.ofNullable(objectObjectHashMap.get(&quot;name1&quot;)) .ifPresent(name -&gt; a.setName(name.toString().toUpperCase())); Optional.ofNullable(objectObjectHashMap.get(&quot;age1&quot;)) .ifPresent(age -&gt; a.setAge(Integer.valueOf(age.toString()) + 18)); System.out.println(a);&#125; 2.链式调用 注意，这里的map可以避免空指针123456789101112131415Integer a = getA(); if (a != null) &#123; Integer b = getB(); if ( b != null) &#123; Integer c = getC(); if ( c != null) &#123; return (a + b) * c; &#125; else return null; &#125; else return null;&#125; else return null;Optional&lt;Integer&gt; result = Optional.ofNullable(getA()) .flatMap(a -&gt; Optional.ofNullable(getB()).map( b -&gt; a + b )) .flatMap(sum -&gt; Optional.ofNullable(getC()).map( c -&gt; sum * c )) 3.使用orelse 为空则返回默认值1234567891011static class UserMapper&#123; public static BizUser selectBizUserByEmployeeNum(String employeeNum) &#123; return null; &#125;&#125;public static void main(String[] args) &#123; BizUser user = UserMapper.selectBizUserByEmployeeNum(&quot;3306&quot;); Optional.ofNullable(user).map(BizUser::getDeptId).filter(deptId -&gt; deptId.intValue() != 0) .orElseThrow(() -&gt; new CustomException(&quot;查询到的user为空！&quot;));&#125;","categories":[],"tags":[]},{"title":"","slug":"新增商品vue总结","date":"2023-04-19T15:25:03.059Z","updated":"2023-04-19T15:25:03.062Z","comments":true,"path":"2023/04/19/新增商品vue总结/","link":"","permalink":"http://example.com/2023/04/19/%E6%96%B0%E5%A2%9E%E5%95%86%E5%93%81vue%E6%80%BB%E7%BB%93/","excerpt":"","text":"#新增商品vue总结 12345678#elemtent 组件#card先展示表单卡片&lt;el-card class=&quot;box-card&quot;&gt; 这里可以定义继续欧雁规则rules &lt;el-form ref=&quot;goods&quot; :rules=&quot;rules&quot; :model=&quot;goods&quot; label-width=&quot;150px&quot;&gt;&lt;/el-from&gt;&lt;/el-card&gt; ##item表单明细用 prop展示属性， 1234&lt;el-form-item label=&quot;市场售价&quot; prop=&quot;counterPrice&quot;&gt; &lt;el-input v-model=&quot;goods.counterPrice&quot; placeholder=&quot;0.00&quot;&gt; &lt;template slot=&quot;append&quot;&gt;元&lt;/template&gt;&lt;/el-input&gt; ##radio 展示单选组件，label是绑定值的 1234567 &lt;el-form-item label=&quot;是否热卖&quot; prop=&quot;isHot&quot;&gt; &lt;el-radio-group v-model=&quot;goods.isHot&quot;&gt; &lt;el-radio :label=&quot;false&quot;&gt;普通&lt;/el-radio&gt; &lt;el-radio :label=&quot;true&quot;&gt;热卖&lt;/el-radio&gt; &lt;/el-radio-group&gt; &lt;/el-form-item&gt; &lt;/el-form-item&gt; ###upload上传图片，这里action 是请求后端的路径，on-exceed是超出数量限制方法，success是成功后方法，这里成功后####直接将file的路径加入到gallery 1234567891011121314151617181920&lt;el-form-item label=&quot;宣传画廊&quot;&gt; &lt;el-upload:action=&quot;uploadPath&quot;:limit=&quot;5&quot;:headers=&quot;headers&quot;:on-exceed=&quot;uploadOverrun&quot;:on-success=&quot;handleGalleryUrl&quot;:on-remove=&quot;handleRemove&quot;multipleaccept=&quot;.jpg,.jpeg,.png,.gif&quot;list-type=&quot;picture-card&quot; &gt; &lt;i class=&quot;el-icon-plus&quot; /&gt; &lt;/el-upload&gt;&lt;/el-form-item&gt;handleGalleryUrl(response, file, fileList)&#123; if (response.errno === 0) &#123; this.goods.gallery.push(response.data.url) &#125;&#125;, ###增加按钮实现，点击增加，是newKeywordVisible的值改变为true，让input组件显示，值默认是false 1234567891011121314&lt;el-form-item label=&quot;关键字&quot;&gt; &lt;el-tag v-for=&quot;tag in keywords&quot; :key=&quot;tag&quot; closable type=&quot;primary&quot; @close=&quot;handleClose(tag)&quot;&gt; &#123;&#123; tag &#125;&#125;&lt;/el-tag&gt;&lt;el-input v-if=&quot;newKeywordVisible&quot; ref=&quot;newKeywordInput&quot; v-model=&quot;newKeyword&quot; class=&quot;input-new-keyword&quot; @keyup.enter.native=&quot;handleInputConfirm&quot; @blur=&quot;handleInputConfirm&quot; /&gt; &lt;el-button v-else class=&quot;button-new-keyword&quot; type=&quot;primary&quot; @click=&quot;showInput&quot;&gt;+ 增加&lt;/el-button&gt;&lt;/el-form-item&gt; ####增加调用showInput方法，这里this.$refs绑定的路由，this.$nextTick表示立即执行 123456showInput() &#123; this.newKeywordVisible = true this.$nextTick(_ =&gt; &#123; this.$refs.newKeywordInput.$refs.input.focus() &#125;) &#125;, ####当调用@keyup.enter.native表示点击输入事件，执行handleInputConfirm方法，此方法就是将newKeyword的值传入keywords，最后keywords 123456789handleInputConfirm() &#123;const newKeyword = this.newKeywordif (newKeyword) &#123;this.keywords.push(newKeyword)this.goods.keywords = this.keywords.toString()&#125;this.newKeywordVisible = falsethis.newKeyword = &#x27;&#x27;&#125;, ####树形组件和普通下拉 123456789&lt;el-form-item label=&quot;所属分类&quot;&gt; &lt;el-cascader :options=&quot;categoryList&quot; expand-trigger=&quot;hover&quot; clearable @change=&quot;handleCategoryChange&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;所属品牌商&quot;&gt; &lt;el-select v-model=&quot;goods.brandId&quot; clearable&gt; &lt;el-option v-for=&quot;item in brandList&quot; :key=&quot;item.value&quot; :label=&quot;item.label&quot; :value=&quot;item.value&quot; /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; #####@change的树形组件value值是数组形式，比如[“zujian”,”form”,”checkbox”]一般获取最后一个vaule值,这里的categoryList是value，lable，chriden三个值，chriden三个值是子数组 123handleCategoryChange(value) &#123; this.goods.categoryId = value[value.length - 1] &#125;, #####点击切换框，这里如果是false，则是默认值，这里的multipleSpec如果是false则隐藏添加 12345678910111213141516171819&lt;el-col&gt;&lt;el-radio-group v-model=&quot;multipleSpec&quot; @change=&quot;specChanged&quot;&gt;&lt;el-radio-button :label=&quot;false&quot;&gt;默认标准规格&lt;/el-radio-button&gt;&lt;el-radio-button :label=&quot;true&quot;&gt;多规格支持&lt;/el-radio-button&gt;&lt;/el-radio-group&gt;&lt;/el-col&gt;&lt;el-col v-if=&quot;multipleSpec&quot; :span=&quot;10&quot;&gt; &lt;el-button :plain=&quot;true&quot; type=&quot;primary&quot; @click=&quot;handleSpecificationShow&quot;&gt;添加&lt;/el-button&gt;&lt;/el-col&gt;specChanged: function(label) &#123; if (label === false) &#123; this.specifications = [&#123; specification: &#x27;规格&#x27;, value: &#x27;标准&#x27;, picUrl: &#x27;&#x27; &#125;] this.products = [&#123; id: 0, specifications: [&#x27;标准&#x27;], price: 0.00, number: 0, url: &#x27;&#x27; &#125;] &#125; else &#123; this.specifications = [] this.products = [] &#125;&#125;， ###slot的用法####slot表示插值，一般用于表单，比如可以设置某个值的样式为按钮botton 1234567&lt;el-table-column property=&quot;value&quot; label=&quot;规格值&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button type=&quot;primary&quot;&gt; &#123;&#123; scope.row.value &#125;&#125; &lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; ###dialog的用法，表示会话，visible.sync一般设置一个boolean值，默认false不显示，当点击是为true，然后确认之后又为false 123456789101112131415161718192021222324252627282930313233343536&lt;el-dialog :visible.sync=&quot;specVisiable&quot; title=&quot;设置规格&quot;&gt; &lt;el-form ref=&quot;specForm&quot; :rules=&quot;rules&quot; :model=&quot;specForm&quot; status-icon label-position=&quot;left&quot; label-width=&quot;100px&quot; style=&quot;width: 400px; margin-left:50px;&quot; &gt; &lt;el-form-item label=&quot;规格名&quot; prop=&quot;specification&quot;&gt; &lt;el-input v-model=&quot;specForm.specification&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;规格值&quot; prop=&quot;value&quot;&gt; &lt;el-input v-model=&quot;specForm.value&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;规格图片&quot; prop=&quot;picUrl&quot;&gt; &lt;el-upload :action=&quot;uploadPath&quot; :show-file-list=&quot;false&quot; :headers=&quot;headers&quot; :on-success=&quot;uploadSpecPicUrl&quot; class=&quot;avatar-uploader&quot; accept=&quot;.jpg,.jpeg,.png,.gif&quot; &gt; &lt;img v-if=&quot;specForm.picUrl&quot; :src=&quot;specForm.picUrl&quot; class=&quot;avatar&quot;&gt; &lt;i v-else class=&quot;el-icon-plus avatar-uploader-icon&quot; /&gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;specVisiable = false&quot;&gt;取消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;handleSpecificationAdd&quot;&gt;确定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/el-card&gt; ###点击确定后执行，将数据加入，使用unshift方法 1234handleAttributeAdd() &#123;this.attributes.unshift(this.attributeForm)this.attributeVisiable = false&#125;, ###一个将元素赋值的方法，这里获取scope.row这一行的元素值，然后Object.assign将元素复制 1234567891011&lt;el-table-column align=&quot;center&quot; label=&quot;操作&quot; width=&quot;100&quot; class-name=&quot;small-padding fixed-width&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; @click=&quot;handleProductShow(scope.row)&quot;&gt;设置&lt;/el-button&gt;&lt;/template&gt;&lt;/el-table-column&gt;handleProductShow(row) &#123; debugger console.log(row) this.productForm = Object.assign(&#123;&#125;, row) this.productVisiable = true &#125;,","categories":[],"tags":[]},{"title":"","slug":"wms部署","date":"2023-04-18T14:59:38.595Z","updated":"2023-04-18T14:59:28.276Z","comments":true,"path":"2023/04/18/wms部署/","link":"","permalink":"http://example.com/2023/04/18/wms%E9%83%A8%E7%BD%B2/","excerpt":"","text":"wms部署##redis部署 1234567891011setenforce 0docker pull redis## 创建目录mkdir -p /home/redis/conf## 创建文件touch /home/redis/conf/redis.confvim /home/redis/conf/redis.confdocker run --name redis -p 6379:6379 \\-v /home/redis/data:/data \\-v /home/redis/conf/redis.conf:/etc/redis/redis.conf \\-d redis:latest redis-server /etc/redis/redis.conf ###redis配置文件，主要是密码和配置持久化 12appendonly yesrequirepass zr525010 ##mysql部署 1234567891011mkdir -p /root/mysql/data /root/mysql/logs /root/mysql/conftouch /root/mysql/conf/my.cnfdocker run \\--name mysql \\-d \\-p 3306:3306 \\--restart unless-stopped \\-v /root/mysql/conf:/etc/mysql/conf.d -v /root/mysql/logs:/var/log/mysql -v /root/mysql/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=admin \\mysql:5.7.37 ##java部署 123456tar -zxvf jdk-8u161-linux-x64.tar.gzvim /etc/profileexport JAVA_HOME=/data/runtime/jdk1.8.0_161export PATH=$PATH:$JAVA_HOME/bin#让配置生效source /etc/profile ###启动项目 12345678#启动项目nohup java -jar yudao-server.jar \\--spring.profiles.active=test \\--server.port=8091 \\&gt;/dev/null 2&gt;&amp;1 &amp;#停止项目ps -ef | grep yudao-server.jar | grep java | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9 ##nginx部署 1234567891011121314151617yum install gcc-c++yum install -y pcre pcre-develyum install -y zlib zlib-develyum install -y openssl openssl-devel#进入官网下载nginx.orgcd /usr/localmkdir nginxtar -zxvf nginx-1.16.1.tar.gzcd /usr/local/nginx./configure --prefix=/usr/local/nginxmake &amp;&amp; make install启动nginxcd /usr/local/nginx./sbin/nginx重启./sbin/nginx -s reload ###nginx配置文件 12345678910111213141516171819202122232425262728293031323334353637worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; gzip_min_length 1k; # 璁剧疆鍏佽鍘嬬缉鐨勯〉闈㈡渶灏忓瓧鑺傛暟 gzip_buffers 4 16k; # 鐢ㄦ潵瀛樺偍 gzip 鐨勫帇缂╃粨鏋 gzip_http_version 1.1; # 璇嗗埆 HTTP 鍗忚鐗堟湰 gzip_comp_level 2; # 璁剧疆 gzip 鐨勫帇缂╂瘮 1-9銆 鍘嬬缉姣旀渶灏忎絾鏈€蹇紝鑰9 鐩稿弽 gzip_types gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; # 鎸囧畾鍘嬬缉绫诲瀷 gzip_proxied any; # 鏃犺鍚庣鏈嶅姟鍣ㄧ殑 headers 澶磋繑鍥炰粈涔堜俊鎭紝閮芥棤鏉′欢鍚敤鍘嬬缉 server &#123; listen 7000; server_name 192.168.2.2; ## 閲嶈锛侊紒锛佷慨鏀规垚浣犵殑澶栫綉 IP/鍩熷悕 location / &#123; ## 鍓嶇椤圭洰 root /data/project/web/dist; index index.html index.htm; try_files $uri $uri/ /index.html; &#125; location /proxy-api/ &#123; proxy_pass http://192.168.2.2:8091/; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"git常用操作","date":"2023-03-08T14:08:25.123Z","updated":"2023-03-08T15:33:58.510Z","comments":true,"path":"2023/03/08/git常用操作/","link":"","permalink":"http://example.com/2023/03/08/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"Git 常用命令： 工作区：指在本地仓库中的全部代码区域； 暂存区：指在本地仓库中通过 git add 后的代码区域； 本地仓库：指在本地仓库中的 git commit 后的代码区域； 远程仓库：远程仓库指的托管代码的服务器。 常用指令git clonegit clone 命令用于将存储库克隆到本地。 12git clone [url] // 将存储库克隆到本地 git initgit init 命令用于在目录中创建新的 Git 仓库。 12- git init // 创建新的 Git 仓库，在当前路径下生成 .git 目录 git remotegit remote 用于管理跟踪远程仓库。 123456git remote -v // 查看连接的远程仓库地址git remote add origin [gitUrl] // 为本地仓库添加远程仓库地址git push -u origin master // 将本地仓库的master和远程仓库的master进行关联git remote origin set-url [gitUrl] // 为本地仓库修改远程仓库地址git remote rm origin // 为本地仓库删除远程仓库连接 git checkoutgit checkout 命令用于切换分支。 123git checkout [branchName] // 切换分支git checkout -b [branchName] // 新建分支并切换到该分支 git branchgit branch 命令用于查看、创建、删除分支。 1234567git branch //查看本地分支git branch -r //查看远程分支git branch -a //查看本地和远程分支git branch [branchName] //新建本地分支但不切换git branch -D [branchName] //删除本地分支git branch -m [oldBranchName] [newBranchName] //重新命名分支 git taggit tag 用于创建、删除、查看标签。 12345git tag [tagName] // 新建标签git tag // 查看标签列表git tag -d [tagName] // 删除标签git push origin [tagName] // 推送标签到远程仓库 git addgit add 命令用于将本地文件添加到暂存区。 12345git add [file1] [file2] // 添加指定文件至暂存区git add [dir] // 添加指定目录至暂存区git add . // 添加当前目录下所有文件至暂存区git add -A // 添加当前仓库下的所有文件改动至暂存区 git commitgit commit 命令用于将暂存区内容添加到本地仓库中。 1234git commit -m &#x27;xxx&#x27; // 将暂存区文件添加到本地仓库，并记录下备注git commit -m &#x27;xxx&#x27; -n // 将暂存区文件添加到本地仓库，并记录下备注，同时跳过 husky hooks 设置的规则校验git commit -am &#x27;xxx&#x27; // 将文件添加到暂存区，再添加到本地仓库，并记录下备注 git pushgit push 命令用于将本地分支推送到远程仓库。 123git push [remoteName] [branchName] // 推送分支git push --set-upstream [remoteName] [branchName] // 推送分支并建立关联关系 git pullgit pull 命令用于从远程仓库拉取代码并合并到本地当前分支。 123git pull // 从远程仓库拉取代码合并到本地，等同于 git fetch &amp;&amp; git mergegit pull --rebase // 使用rebase的模式进行合并 git fetchgit fetch 命令用于从远程获取代码库。 1234git fetch // 从所有远程仓库拉取当前分支代码git fetch [remoteName] // 从指定远程仓库拉取当前分支代码git fetch --all // 获取所有远程仓库所有分支的更新 git cherry-pickgit cherry-pick 命令用于获取指定的 commit，可以将分支 a 上的 commit 1，复制到分支 b上。 12git cherry-pick [commitId] // 获取指定的commit git mergegit merge 命令用于分支合并，将其他分支的内容合并到当前分支中。 12git merge [branchName] git rebasegit rebase 用于分支变基。 12git rebase master // 将当前分支变基到 master 分支上 git rebase -i 交互模式： 12git rebase -i [commitId] // 基于 commitId 进行 rebase，交互式变基，可以重新编辑 commit，比如压缩合并 git resetgit reset 命令用于回退版本，可以指定退回某一次提交的版本。 1234567git reset HEAD^ // 回退所有内容到上一个版本git reset HEAD^ [filename] // 回退某文件到上一个版本git reset [commitId] // 回退所有内容到指定版本git reset --soft HEAD~1 // 回退本地仓库到上一个版本git reset --hard HEAD~1 // 回退本地仓库到上一个版本，并删除工作区所有未提交的修改内容复制代码 git revertgit revert 指令用于回滚提交，可以回滚某一次提交记录。 123git revert [commitId] // 回滚某次提交git revert [commitId] -m 1 // 回滚某次 merge 的 commit，1 代表保留主分支代码 git stashgit stash 用于暂存文件。 12345678git stash // 暂存文件git stash save &#x27;aa&#x27; // 暂存文件，添加备注git stash pop // 应用最近一次暂存文件，并删除暂存记录git stash apply // 应用最近一次暂存，但不删除该暂存记录git stash apply stash@&#123;第几次暂存的代码，例如0&#125; // 应用某一次暂存，但不删除该暂存记录；git stash list // 暂存记录git stash clear // 删除所有暂存记录复制代码 git refloggit reflog 记录了所有的 commit 操作记录，便于错误操作后找回。 12git reflog git rmgit rm 用于从 git 仓库删除指定文件或目录。 123git rm [filname]git rm [dir] git loggit log 命令用于查看 git commit 记录。 12git log // 查看所有 commit 记录git log --grep 瀑布流 // 搜索 commit msg 有瀑布流关键字的 记录","categories":[],"tags":[]},{"title":"","slug":"git 一般操作","date":"2023-01-16T13:53:13.892Z","updated":"2023-01-16T13:53:37.076Z","comments":true,"path":"2023/01/16/git 一般操作/","link":"","permalink":"http://example.com/2023/01/16/git%20%E4%B8%80%E8%88%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"Git global setup12git config --global user.name &quot;Administrator&quot;git config --global user.email &quot;admin@example.com&quot; Create a new repository1234567git clone ssh://git@192.168.2.2:222/root/newbeemallplus.gitcd newbeemallplusgit switch -c maintouch README.mdgit add README.mdgit commit -m &quot;add README&quot;git push -u origin main Push an existing folder123456cd existing_foldergit init --initial-branch=maingit remote add origin ssh://git@192.168.2.2:222/root/newbeemallplus.gitgit add .git commit -m &quot;Initial commit&quot;git push -u origin main Push an existing Git repository12345cd existing_repogit remote rename origin old-origingit remote add origin ssh://git@192.168.2.2:222/root/newbeemallplus.gitgit push -u origin --allgit push -u origin --tags","categories":[],"tags":[]},{"title":"","slug":"docker部署springboot项目","date":"2022-09-17T12:34:13.529Z","updated":"2022-09-17T14:25:04.647Z","comments":true,"path":"2022/09/17/docker部署springboot项目/","link":"","permalink":"http://example.com/2022/09/17/docker%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"docker部署springboot项目本文主要介绍docker如何部署springboot项目 创建一个springboot项目，打包成jar包该项目端口为8081，logback日志目录为/home/docker/logs 准备一台搭建好了docker的linux服务器linux搭建docker攻略移步：https://www.cnblogs.com/lixianguo/p/13254950.html创建/home/docker文件夹，将打包的jar包上传创建/home/docker/logs文件夹存放日志文件，该路径与项目中logback中设置的一致创建Dockerfile,内容如下 12345678910#指定基础镜像，不需要另外安装jdkFROM java:8#维护者MAINTAINER lxg#将本地文件添加到容器中，并更名为myproject.jarCOPY springboot-docker-1.0-SNAPSHOT.jar myproject.jar#指定访问端口，与yml文件中的端口一致EXPOSE 8081#容器启动时，运行该程序ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;myproject.jar&quot;] 目录截图如下 使用命令构建镜像最后空格和”.”不可忽略 1docker build -t myproject . 创建并启动容器123docker run -p 8080:8081 --name myproject \\&gt; -v /home/docker/logs:/home/docker/logs \\&gt; -d myproject 8080是外界访问的端口，可以自定义，8081是Dockerfile中定义的端口。-v是为了将容器中的日志目录挂载出来，冒号之前是linux宿主机自己创建的目录，可以自定义。后面的是logback文件中定义的输出日志的目录。","categories":[],"tags":[]},{"title":"","slug":"lamdba表达式的运用总结","date":"2022-08-26T06:22:39.859Z","updated":"2022-08-26T06:40:21.434Z","comments":true,"path":"2022/08/26/lamdba表达式的运用总结/","link":"","permalink":"http://example.com/2022/08/26/lamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%BF%90%E7%94%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"lambda表达式总结（集合操作）1.集合的排序123456Comparator&lt;Hero&gt; comparator=new Comparator&lt;Hero&gt;() &#123; @Override public int compare(Hero o1, Hero o2) &#123; return o1.getHp()-o2.getHp(); &#125;&#125;; 先写一个comparator,根据age排序 然后调用 1List&lt;Hero&gt; sortHeroList=heroList.stream().sorted(comparator).collect(Collectors.toList()); 2.最大最小值的属性以及具体元素1Hero maxAgeHero=heroList.stream().max(comparator).get(); 3.去重一般去重1List&lt;Hero&gt; heroeDistinct=heroList.stream().distinct().collect(Collectors.toList()); 4.求和一般求和1int sum=heroList.stream().mapToInt(Hero::getHp).sum(); 大数类求和 1BigDecimal totalQuantity = bigDecimalList.stream().map(Hero::getHp).reduce(BigDecimal.ZERO,BigDecimal::add); 5.分组根据某个属性分组并且转成Map&lt;String,List&gt; 1Map&lt;String,List&lt;Hero&gt;&gt; groupMap=heroList.stream().collect(Collectors.groupingBy(Hero::getSex)); 6.list转为map12//list转为map,如果重复，则取k1的值Map&lt;Integer,Hero&gt; heroMap=heroList.stream().collect(Collectors.toMap(Hero::getHp,a-&gt;a,(k1,k2)-&gt;k1)); 7. 新的list12//获取某个值转为新的listList&lt;Integer&gt; heroAgeList=heroList.stream().map(a-&gt;a.getHp()).collect(Collectors.toList()); 8.过滤1List&lt;Hero&gt; heroList1=heroList.stream().filter(hero -&gt; hero.getHp()&lt;300&amp;&amp;hero.getHp()&gt;100).collect(Collectors.toList()); 总结表达式主要分为中间过程和结束操作 零个或多个中间操作： 每个中间操作会返回一个流，如filter,中间操作时懒操作，不会真正遍历​ 中间操作有很多种，主要分为两种： ​ 1.对元素进行筛选：filter（匹配），distinct（去除重复）,sorted（自然排序） ​ sorted(Comparator)（指定排序），limit（保留），skip（忽略） ​ 2.转为其他形式的流：mapToDouble（转为double的流）, map（转换为任意类型的流） 结束操作： 例如forEach，会返回非流结果，例如基本类型的值（int,float,double）、对象或者集合，或者在终端操作为forEach的情况下没有返回值。​ 结束操作时才真正进行遍历行为，前面的中间操作也在这个时候真正的执行。 ​ 常见的结束操作如下： ​ forEach()（遍历每个元素），toArray()（转换为数组），min(Comparator)（取最小的元素） ​ max(Comparator)（取最大的元素），count()（总数），findFirst()（第一个元素）.get(). 以及Collectors.toList()转为list","categories":[],"tags":[]},{"title":"","slug":"dockers部署jenkins和gitlab总结","date":"2022-08-22T01:14:42.339Z","updated":"2023-02-14T01:40:43.571Z","comments":true,"path":"2022/08/22/dockers部署jenkins和gitlab总结/","link":"","permalink":"http://example.com/2022/08/22/dockers%E9%83%A8%E7%BD%B2jenkins%E5%92%8Cgitlab%E6%80%BB%E7%BB%93/","excerpt":"","text":"docker部署jenkins和gitlab总结jenkins安装1拉取docker镜像并启动docker pull jenkinsci/blueoceandocker run -e JAVA_OPTS=”-Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true” –name jenkins -u root –rm -d -p 7005:8080 -p 50000:50000 -v /data/service/jenkins:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v /data/service/apache-maven-3.8.5:/usr/local/maven -v /data/service/jdk1.8.0_212:/usr/local/jdk jenkinsci/blueocean 注意，这里的run -e JAVA_OPTS=”-Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true” –name 是用来允许跨网站请求伪造，方便后来部署webhook –rm代表stop容器后就删除了容器 -v代表挂载，这里分别挂载jenkins目录，maven目录，jdk目录 -name代表容器名是jenkens ，这个可以直接通过docker rm Jenkins就删除了jenkins目录 -p代表端口映射，这里是代表容器在7005端口启动 启动后访问 ip:7005 2查看密码登录查看密码 ，目录文件为/data/service/Jenkins cat /data/service/jenkins/secrets/initialAdminPassword 3配置环境变量和git设置全局工作变量 ，git和java是有的，不用配置 这里只用配置maven环境变量，地址是docker容器内的 首先生成公钥 进入jinkins容器后执行 docker exec -it jenkins bash ssh-keygen -t rsa -C ‘&#49;&#53;&#48;&#49;&#57;&#52;&#x37;&#52;&#57;&#53;&#x31;&#x40;&#49;&#54;&#x33;&#46;&#99;&#x6f;&#x6d;’ cat ~/.ssh/id_rsa.pub 将公钥填入 新建一个自由风格项目 这里将刚才的公钥填入 4安装ssh插件并执行远程ssh连接搜索 Publish over SSH 插件安装，搜索 Maven Integration 插件安装 在系统设置下配置远程连接，这里我配置主机地址,找到Publish over SSH 接着构建项目 主要流程是先打包项目，然后把git目录下的项目的包发送 这里首先是Soure set这里代表git根目录下的地址 remove prefix代表去除项目前缀，可以不配置 关键是remote directory 这里是用户的目录地址下的，这是个坑，即如果是root目录，则是/root/data/test，即用户打包的东西会传到这个目录下 这里的shell命令就是删除原来的进程然后构建 webhook配置webhook配置\\1. 安装Generic Webhook Trigger插件 \\2. 加入git的公钥到jenkins \\3. 生成key ssh-keygen -t rsa -C ‘&#x31;&#x35;&#x31;&#55;&#x32;&#53;&#x33;&#x37;&#x30;&#52;&#x39;&#x40;&#x31;&#x36;&#x33;&#46;&#x63;&#111;&#x6d;‘ cat ~/.ssh/id_rsa.pub \\4. 将构建触发器勾上! \\5. 配置apitoken，这里是后面APItoken的地址 这里是在用户配置哪里，点设置，进去之后就能看到apitoken 先找到设置然后打勾 \\1. 找到WebHooks配置界面，在POST地址框中输入如下格式内容： \\2. \\3. http://:@&lt;Jenkins IP地址&gt;:端口/generic-webhook-trigger/invoke \\4. 添加url http://root:1148e42061461a8d68883794319c3dcd82@192.168.2.2:7005/generic-webhook-trigger/invoke 配置gitlab拉docker 并启动docker pull gitlab/gitlab-cedocker run -d -p 443:443 -p 81:80 -p 222:22 –name gitlab –restart always -v /root/gitlab/config:/etc/gitlab -v /root/gitlab/logs:/var/log/gitlab -v /root/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce 配置启动路径gitlab.rb文件内容默认全是注释 $ vim /root/gitlab/config/gitlab.rb 配置http协议所使用的访问地址,不加端口号默认为80 external_url ‘http://192.168.2.7&#39; external_url ‘http://120.77.247.123&#39; 配置ssh协议所使用的访问地址和端口 gitlab_rails[‘gitlab_ssh_host’] = ‘192.168.2.7 ‘gitlab_rails[‘gitlab_shell_ssh_port’] = 222 # 此端口是run时22端口映射的222端口:wq #保存配置文件并退出重启gitlab容器 $ docker restart gitlabGitLab占用内存非常恐怖，解决方法很简单 修改/root/gitlab/config/gitlab/gitlab.rb 文件，将 unicorn[‘worker_processes’] = 2 去掉注释就可以了。在注释的情况下默认是服务器上的所有线程。 重置root密码docker exec -it gitlab /bin/bash启用docker里面gitlab的ruby 注意，这里一定要等到控制台打印信息后才能输入下面的usergitlab-rails console -e production 找到管理员用户user = User.where(id: 1).first 更改密码user.password = ‘abcd1234’user.password_confirmation = ‘abcd1234’记得保存user.save! ​","categories":[],"tags":[]},{"title":"","slug":"部署ruoyi前后端分离版","date":"2022-08-18T09:29:31.771Z","updated":"2024-06-19T05:06:34.143Z","comments":true,"path":"2022/08/18/部署ruoyi前后端分离版/","link":"","permalink":"http://example.com/2022/08/18/%E9%83%A8%E7%BD%B2ruoyi%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%89%88/","excerpt":"","text":"部署ruoyi前后端分离版此步骤在不分离版后延续redis启动docker pull redis:latest docker run –restart=always -p 6379:6379 –name myredis -d redis:latest –requirepass .zrlst1314 nodejscd /data/tmptar -zxvf node-v14.15.5-linux-x64.tar.gzmv node-v14.15.5-linux-x64 /data/servicecd /data/servicell配置环境变量vim /etc/profileexport NODEJS_HOME=/data/service/node-v14.15.5-linux-x64export PATH=$PATH:$NODEJS_HOME/binsource /etc/profile nginxcd /data/tmp yum install -y gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel tar zxvf nginx-1.18.0.tar.gzcd nginx-1.18.0./configure –prefix=/data/service/ngnix –with-http_stub_status_module –with-http_ssl_modulemake &amp;&amp; make install/data/service/ngnix/sbin/nginx git拉代码并修改配置文件，打包cd /data/giteegit clone &#103;&#x69;&#x74;&#64;&#x67;&#x69;&#x74;&#x65;&#101;&#x2e;&#99;&#x6f;&#109;:y_project/RuoYi-Vue.gitcd /data/gitee/RuoYi-Vue/ruoyi-admin/src/main/resources/#修改application.yml的项目启动端口号与文件上传路径vim application.yml#修改application-druid.yml的数据源vim application-druid.ymlcd /data/gitee/RuoYi-Vue/mvn clean install -pl com.ruoyi:ruoyi-admin -ammkdir -p /data/app/ruoyi-vuecp /data/gitee/RuoYi-Vue/ruoyi-admin/target/ruoyi-admin.jar /data/app/ruoyi-vue/ruoyi-admin.jarcd /data/app/ruoyi-vue/#后台启动项目nohup java -jar ruoyi-admin.jar &amp;#查看项目运行日志tail -f nohup.out 启动前端项目1、下载依赖并打包cd /data/gitee/RuoYi-Vue/ruoyi-uinpm install –registry=https://registry.npmmirror.comnpm installmkdir /data/app/ruoyi-uimv dist/* /data/app/ruoyi-ui/ 配置nginx此处/代表根目录 root配置的dist的明确地址 /prod-api/配置的是转发路径，及前端请求都转发到 localhost:18081地址 ​ location / {​ root /data/app/ruoyi-ui/dist; 此处为前端dist路径​ index index.html index.htm;​ }​ location /prod-api/ { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://localhost:18081/; 此处为后端项目路径}重启nginx/data/service/ngnix/sbin/nginx -s reload访问 192.168.2..6:80","categories":[],"tags":[]},{"title":"","slug":"部署ruoyi前后端不分离版","date":"2022-08-18T08:51:40.113Z","updated":"2024-07-14T09:34:34.543Z","comments":true,"path":"2022/08/18/部署ruoyi前后端不分离版/","link":"","permalink":"http://example.com/2022/08/18/%E9%83%A8%E7%BD%B2ruoyi%E5%89%8D%E5%90%8E%E7%AB%AF%E4%B8%8D%E5%88%86%E7%A6%BB%E7%89%88/","excerpt":"","text":"部署ruoyi前后端不分离版项目目录 #tmp存放临时安装包mkdir -p /data/tmp#service存放软件环境mkdir -p /data/service#gitee存放代码版本控制库mkdir -p /data/gitee 安装javajavacd /data/tmptar -zxvf jdk-8u212-linux-x64.tar.gzmv jdk1.8.0_212 /data/servicecd /data/servicellvim /etc/profileexport JAVA_HOME=/data/service/jdk1.8.0_212export PATH=$PATH:$JAVA_HOME/binsource /etc/profile 安装mavencd /data/tmptar -zxvf apache-maven-3.8.5-bin.tar.gzmv apache-maven-3.8.5 /data/servicecd /data/servicellvim /etc/profileexport MAVEN_HOME=/data/service/apache-maven-3.8.5export PATH=$PATH:$MAVEN_HOME/binsource /etc/profilevim /data/service/apache-maven-3.8.5/conf/setting.xml#配置本地仓库/data/service/apache-maven-3.8.5/repository#配置阿里云镜像 aliyunmaven * 阿里云公共仓库 https://maven.aliyun.com/repository/public 安装gityum -y groupinstall “Development Tools”yum install wget unzip gettext-devel openssl-devel perl-CPAN perl-devel zlib-devel libcurl-devel expat-devel -ycd /data/tmptar zxvf git-2.18.0.tar.gzcd git-2.18.0./configure –prefix=/data/service/gitmake &amp;&amp; make installvim /etc/profileexport GIT_HOME=/data/service/gitexport PATH=$PATH:$GIT_HOME/binsource /etc/profile git公钥，和下载项目git密匙ssh-keygen -t rsa -C “&#x31;&#x35;&#49;&#x37;&#50;&#x35;&#51;&#x37;&#48;&#52;&#57;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#x6d;“cat ~/.ssh/id_rsa.pub//粘到公匙ssh -T &#103;&#x69;&#x74;&#64;&#103;&#x69;&#x74;&#x65;&#101;&#46;&#x63;&#x6f;&#x6d;cd /data/giteegit clone &#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#101;&#101;&#46;&#x63;&#111;&#x6d;:y_project/RuoYi.git docker安装docker安装sudo yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-enginesudo yum install -y yum-utils device-mapper-persistent-data lvm2sudo yum-config-manager –add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repoyum install -y https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/edge/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpmyum install docker-ce docker-ce-cli -ysudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-‘EOF’{ “registry-mirrors”: [“https://plb9xzjh.mirror.aliyuncs.com&quot;]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker mysql安装docker pull mysql:5.7mkdir -p /root/mysql/data /root/mysql/logs /root/mysql/conftouch /root/mysql/conf/my.cnf//密码是admin，-v则是挂载 –name容器名字，作为后面的启动删除名字docker run -p 3306:3306 –rm –name mysql -v /root/mysql/conf:/etc/mysql/conf.d -v /root/mysql/logs:/var/log/mysql -v /root/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=.zrlst1314 -d mysql:5.7docker start mysql//进入容器docker exec -it mysql /bin/bash#登录docker容器（方式参考上方文档）后登录mysqlmysql -uroot -padmin#修改登录者的权限GRANT ALL ON . TO ‘root‘@’%’;#刷新命令生效 flush privileges; 修改项目配置cd /data/gitee/RuoYi/ruoyi-admin/src/main/resources/#修改application.yml的项目启动端口号与文件上传路径vim application.yml#修改application-druid.yml的数据源vim application-druid.yml 打包启动cd /data/gitee/RuoYi/mvn installmkdir -p /data/app/ruoyi-admincp /data/gitee/RuoYi/ruoyi-admin/target/ruoyi-admin.jar /data/app/ruoyi-admin/ruoyi-admin.jarcd /data/app/ruoyi-admin/#后台启动项目 nohup java -jar yudao-server.jar –spring.profiles.active=dev &amp;#查看项目运行日志tail -f nohup.out 开放端口重启防火墙firewall-cmd –permanent –add-port=80/tcpfirewall-cmd –reload","categories":[],"tags":[]},{"title":"","slug":"回溯，双指针，和栈的运用","date":"2022-07-25T02:59:38.180Z","updated":"2022-07-25T03:35:30.960Z","comments":true,"path":"2022/07/25/回溯，双指针，和栈的运用/","link":"","permalink":"http://example.com/2022/07/25/%E5%9B%9E%E6%BA%AF%EF%BC%8C%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%8C%E5%92%8C%E6%A0%88%E7%9A%84%E8%BF%90%E7%94%A8/","excerpt":"","text":"回溯，双指针，和栈的个人总结1.回溯给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1：输入：candidates = [2,3,6,7], target = 7, 个人思路总结常规回溯，回溯的下一次target为 target-candidates【i】，首先将数组排序，每次回溯时候，当target-candidate[i]&lt;0时候，则终止回溯，剪枝干。当target==0时候，则保留结果。注意结果不重复，则每次是以begin开始。 代码如下 2.双指针 给定n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 个人思路总结我们可以按照分列的思路解，遍历每一列，第一列，最后一列，不积水，跳过，第二列开始，每列积水高度由该列左边最高列，右边最高列中最短的列减去该列高度决定，如果该值小于零，则舍弃，大于零，则累加。 代码如下 3.栈的运用给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: “()” 输出: true 示例 2: 输入: “()[]{}” 输出: true 个人思路如果遇到左括号，则将右括号入栈。如果是右括号，则判断是不是和栈顶弹出的元素相同，如果不相同则false，如果相同则弹出，如果栈为空 则直接false，因为此时后面都是弹出的。 代码","categories":[],"tags":[]},{"title":"","slug":"算法-回溯总结","date":"2022-07-15T14:11:42.844Z","updated":"2022-07-15T14:18:56.333Z","comments":true,"path":"2022/07/15/算法-回溯总结/","link":"","permalink":"http://example.com/2022/07/15/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93/","excerpt":"","text":"回溯总结题目给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例:输入：”23”输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. 个人思路可以维护一个2-9对应字母的数组，为String[] numsString={“”, “”, “abc”, “def”, “ghi”, “jkl”, “mno”, “pqrs”, “tuv”, “wxyz”}; 则2-9分别有了对应关系，用dfs(String digits,int nums,String[] numsString)表示从下表nums开始回溯，则终止条件为nums==digits.length()，获取每个数字对应的temp，遍历temp，下标加一进行回溯，最后要移除最后一个字母 代码如下","categories":[],"tags":[]},{"title":"","slug":"算法-双指针和hashmap的运用","date":"2022-07-14T08:26:47.912Z","updated":"2022-07-14T08:53:08.827Z","comments":true,"path":"2022/07/14/算法-双指针和hashmap的运用/","link":"","permalink":"http://example.com/2022/07/14/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88%E5%92%8Chashmap%E7%9A%84%E8%BF%90%E7%94%A8/","excerpt":"","text":"算法-双指针和hashmap的运用1.两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 个人思路遍历数组，计算和目标的差额temp，并把数组放入hashmap，调用hashmap.put(nums[i],i)方法，如果hashmap中包含temp这个key，则是一种答案 2.最长回文子串给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 输入：s = “babad” 输出：”bab” 解释：”aba” 同样是符合题意的答案。 个人思路遍历字符串，每种i代表以什么为中心，分两种情况，一种是一个字符为中心朝两边扩展 ，如“bab”，中心是a，第二种是以两个字符为中心像两边扩展，如“baab”，中心是aa，创建extend（String s,int start,int end）方法，其中start，end方法代表字符截取的下标，如果s.chartAT(start)==s.chartAT(end)则start–，end++，最后返回最长的那个即是答案。 3.三数之和给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意： 答案中不可以包含重复的三元组。 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 个人思路遍历 字符串，i下表表示第一个数字索引，剩下两个两个数一个为i+1，一个为length-1，如果 nums【i】+nums【left】+nums【right】大于0，则 right–，否则left++；如果等于0，则right–，left++；另外等于0时候，则要考虑重复，如果这个 nums【right】==nums【right+1】则right–，就会去除重复","categories":[],"tags":[]},{"title":"","slug":"token的一点个人总结","date":"2022-07-08T15:12:08.053Z","updated":"2022-07-08T15:33:28.646Z","comments":true,"path":"2022/07/08/token的一点个人总结/","link":"","permalink":"http://example.com/2022/07/08/token%E7%9A%84%E4%B8%80%E7%82%B9%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/","excerpt":"","text":"token的个人总结token的组成1.header 元数据，定义token的类型和加密算法 2.payload token的具体数据，比如userid就是放在payload中 3.sign 签名 服务器通过Payload、Header和一个密钥(secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。 生成token方法调用 jwt.creat()方法生成，具体如下，先用SHA256算法将sercret加密，放入sign中，将userid放入payload中，定义header的加密算法和token类型 解析token方法，并获取userid主要是先根据sign获取到JWTVerifier对象，再获取DecodeJwt对象，最后将payload中uerid取出 总之，token是根据签名的加密算法生成sign，再根据sign反解析得到JWTVerifier，并可以把userid放入clamims中 token的一些好处1.无状态 2.有效避免了CSRF 攻击（大部分情况下存放在 local storage ）","categories":[],"tags":[]},{"title":"","slug":"Redis持久化机制","date":"2022-07-07T12:45:30.724Z","updated":"2022-07-07T12:49:04.246Z","comments":true,"path":"2022/07/07/Redis持久化机制/","link":"","permalink":"http://example.com/2022/07/07/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Redis 持久化机制很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。 Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。 快照（snapshotting）持久化（RDB） Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。 快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置： 12345save 900 1 #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。save 300 10 #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。save 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。 AOF（append-only file）持久化 与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启： 1appendonly yes 1 开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 server.aof_buf 中，然后再根据 appendfsync 配置来决定何时将其同步到硬盘中的 AOF 文件。 AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。 在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：appendfsync always #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度appendfsync everysec #每秒钟同步一次，显式地将多个写命令同步到硬盘appendfsync no #让操作系统决定何时进行同步","categories":[],"tags":[]},{"title":"","slug":"ThreadPoolExecutor 类分析","date":"2022-07-07T11:59:47.199Z","updated":"2022-07-07T12:25:56.716Z","comments":true,"path":"2022/07/07/ThreadPoolExecutor 类分析/","link":"","permalink":"http://example.com/2022/07/07/ThreadPoolExecutor%20%E7%B1%BB%E5%88%86%E6%9E%90/","excerpt":"","text":"线程池总结ThreadPoolExecutor 3 个最重要的参数： corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。 maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。 workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。 线程池的执行策略 线程池和callable一起使用，一般用来有返回值得类型第一 创建线程池 1private static ThreadPoolExecutor executorService = new ThreadPoolExecutor(9, 9, 1000, TimeUnit.MILLISECONDS, WORK_QUEUE, HANDLER); ​ 第二 重写callable方法 ​ Callable bannerListCallable = () -&gt; adService.queryIndex(); ​ 第三步 调用线程池submit方法，获取future对象 ​ Future banner=executorService.submit(bannerListCallable); ​ 第四步，调用future.get方法获取返回值 ​ Map&lt;String, Object&gt; entity = new HashMap&lt;&gt;(); ​ entity.put(“banner”, banner.get());","categories":[],"tags":[]},{"title":"","slug":"递归的一点思考","date":"2022-07-07T11:11:15.948Z","updated":"2022-07-07T12:26:34.949Z","comments":true,"path":"2022/07/07/递归的一点思考/","link":"","permalink":"http://example.com/2022/07/07/%E9%80%92%E5%BD%92%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/","excerpt":"","text":"递归的一点思考递归就是将大问题转化为小问题的一种思路。 它有两个特点， 1.重复调用自身函数 2.有终结条件 例如leetcode题目二叉树的中序遍历就可用递归","categories":[],"tags":[]},{"title":"","slug":"若依项目前后端分离部署","date":"2022-06-15T08:32:27.658Z","updated":"2022-07-07T12:27:57.561Z","comments":true,"path":"2022/06/15/若依项目前后端分离部署/","link":"","permalink":"http://example.com/2022/06/15/%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%83%A8%E7%BD%B2/","excerpt":"","text":"若依项目前后端分离部署启动防火墙 systemctl start firewalld 端口占用netstat -npl | grep “80” #开放端口 firewall-cmd –permanent –add-port=3306/tcp #重启防火墙firewall-cmd –reload #mysql安装docker pull mysql:5.7.30mkdir -p /root/mysql/data /root/mysql/logs /root/mysql/conftouch /root/mysql/conf/my.cnf//密码是admin，-v则是挂载 –name容器名字，作为后面的启动删除名字docker run -p 3306:3306 –rm –name mysql -v /root/mysql/conf:/etc/mysql/conf.d -v /root/mysql/logs:/var/log/mysql -v /root/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=admin -d mysql:5.7.30docker start mysql //进入容器docker exec -it mysql /bin/bash登录docker容器（方式参考上方文档)后登录mysqlmysql -uroot -padmin修改登录者的权限GRANT ALL ON . TO ‘root‘@’%’;#刷新命令生效 flush privileges; #重启mysql //docker rm mysqldocker run -p 3306:3306 –rm –name mysql -v /root/mysql/conf:/etc/mysql/conf.d -v /root/mysql/logs:/var/log/mysql -v /root/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=admin -d mysql:5.7.30重启redis//docker run -d –rm -v /root/redis/data:/data –name redis -p 6379:6379 redis redis-server –appendonly yes 重启nginx/data/service/ngnix/sbin/nginx -s reload 重启nginx // cd /data/tmpmake install/data/service/ngnix/sbin/nginx #Jenkins安装docker pull jenkinsci/blueoceandocker run –name jenkins -u root –rm -d -p 7005:8080 -p 50000:50000 -v /data/service/jenkins:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v /data/service/apache-maven-3.8.5:/usr/local/maven -v /data/service/jdk1.8.0_212:/usr/local/jdk jenkinsci/blueocean-u root：以 root 权限启动，防止出现权限问题-p 7005:8080：端口映射，服务器的 7005 端口映射容器的 8080 端口-p 50000:50000：Jenkins代理默认通过TCP端口50000与Jenkins主机通信-v /data/jenkins:/var/jenkins_home：把容器内的 Jenkins 目录挂载到服务器的 /data/jenkins 目录以防容器没了，数据也没了-v /var/run/docker.sock:/var/run/docker.sock：保证容器内的 docker 与 服务器上 docker 的通讯 附带下删除 jenkinsci/blueocean 容器 删除对应绑定网桥docker network disconnect –force bridge jenkinsci-blueocean 删除 jenkinsci-blueocean 容器，xxxx 容器 IDdocker rm -f xxxx查看密码 ，目录文件为/data/service/Jenkinscat /data/service/jenkins/secrets/initialAdminPasswordJenkisn部署项目 1.全局工作配置这里的java_home 路劲是docker挂载 路径，这里的maven路进是挂载路径注意：只用修改java和maven，git是已经有的2.插件安装搜索 Publish over SSH 插件安装，搜索 Maven Integration 插件安装3.ssh连接在系统设置下配置远程连接，这里我配置主机地址4.进入git项目配置 首先生成公钥进入jinkins容器后执行Docker exec -it dockerid bashssh-keygen -t rsa -C ‘&#x31;&#x35;&#48;&#49;&#57;&#x34;&#x37;&#52;&#57;&#x35;&#x31;&#x40;&#x31;&#54;&#51;&#46;&#99;&#x6f;&#109;’cat ~/.ssh/id_rsa.pub将公钥粘入gitee 在安全认证中把公钥加入5，进入项目配置悬念则git仓库，选择刚才配置公钥 .选择6.选择ssh接入下面的shell如下cd /root/data/testid=$(ps -ef | grep “ruoyi-admin.jar” | grep -v grep| awk ‘{print $2}’)echo $idkill -9 $idnohup /data/service/jdk1.8.0_212/bin/java -jar ruoyi-admin.jar &gt;myout.log 2&gt;&amp;1 &amp;注意，这里一定要指定java执行路径 这里是/data/service/jdk1.8.0_212/bin/java，这是个大坑, 这里的远程目录是在/root下，即如果配置/data/test,则最终路径是在/root/data/test部署gitlabdocker pull gitlab/gitlab-cedocker run -d -p 443:443 -p 80:80 -p 222:22 –name gitlab –restart always -v /root/gitlab/config:/etc/gitlab -v /root/gitlab/logs:/var/log/gitlab -v /root/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce gitlab.rb文件内容默认全是注释$ vim /root/gitlab/config/gitlab.rb 配置http协议所使用的访问地址,不加端口号默认为80external_url ‘http://192.168.2.2&#39; 配置ssh协议所使用的访问地址和端口gitlab_rails[‘gitlab_ssh_host’] = ‘192.168.2.2 ‘gitlab_rails[‘gitlab_shell_ssh_port’] = 222 # 此端口是run时22端口映射的222端口:wq #保存配置文件并退出重启gitlab容器$ docker restart gitlab重置root密码docker exec -it gitlab（容器名字） /bin/bash启用docker里面gitlab的rubygitlab-rails console -e production 找到管理员用户user = User.where(id: 1).first 更改密码user.password = ‘abcd1234’user.password_confirmation = ‘abcd1234’记得保存user.save! webhook配置 安装Generic Webhook Trigger插件 加入git的公钥到jenkins 生成key ssh-keygen -t rsa -C ‘&#x31;&#x35;&#49;&#55;&#50;&#x35;&#x33;&#x37;&#x30;&#x34;&#x39;&#x40;&#x31;&#54;&#51;&#46;&#99;&#111;&#x6d;‘ cat ~/.ssh/id_rsa.pub 配置apitoken，这里是后面APItoken的地址6. 允许本地访问该地址 在menu-admin-setting-network7.8. 找到WebHooks配置界面，在POST地址框中输入如下格式内容：9.10. http://:@&lt;Jenkins IP地址&gt;:端口/generic-webhook-trigger/invoke11. 添加urlhttp://root:1148e42061461a8d68883794319c3dcd82@192.168.2.2:7005/generic-webhook-trigger/invoke 配置固定ip地址虚拟机安装Linux系列教材 （八）- 设置 Centos7 为固定ip地址 (how2j.cn)需要注意编写ens33时候 onboot=yes如果出现报错”Could not resolve host: mirrorlist.centos.org; Unknown error”则在”Could not resolve host: mirrorlist.centos.org; Unknown error”解决方法 - Mr.Gavin - 博客园 (cnblogs.com)处理 Ipv4转发（连接不上数据库）2.开启转发配置 vim /etc/sysctl.conf #配置转发net.ipv4.ip_forward=1#保存退出就可以了:wq!#重启服务，让配置生效systemctl restart network","categories":[],"tags":[]}],"categories":[],"tags":[]}