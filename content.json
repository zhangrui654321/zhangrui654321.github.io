{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"git常用操作","date":"2023-03-08T14:08:25.123Z","updated":"2023-03-08T15:33:58.510Z","comments":true,"path":"2023/03/08/git常用操作/","link":"","permalink":"http://example.com/2023/03/08/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"Git 常用命令： 工作区：指在本地仓库中的全部代码区域； 暂存区：指在本地仓库中通过 git add 后的代码区域； 本地仓库：指在本地仓库中的 git commit 后的代码区域； 远程仓库：远程仓库指的托管代码的服务器。 常用指令git clonegit clone 命令用于将存储库克隆到本地。 12git clone [url] // 将存储库克隆到本地 git initgit init 命令用于在目录中创建新的 Git 仓库。 12- git init // 创建新的 Git 仓库，在当前路径下生成 .git 目录 git remotegit remote 用于管理跟踪远程仓库。 123456git remote -v // 查看连接的远程仓库地址git remote add origin [gitUrl] // 为本地仓库添加远程仓库地址git push -u origin master // 将本地仓库的master和远程仓库的master进行关联git remote origin set-url [gitUrl] // 为本地仓库修改远程仓库地址git remote rm origin // 为本地仓库删除远程仓库连接 git checkoutgit checkout 命令用于切换分支。 123git checkout [branchName] // 切换分支git checkout -b [branchName] // 新建分支并切换到该分支 git branchgit branch 命令用于查看、创建、删除分支。 1234567git branch //查看本地分支git branch -r //查看远程分支git branch -a //查看本地和远程分支git branch [branchName] //新建本地分支但不切换git branch -D [branchName] //删除本地分支git branch -m [oldBranchName] [newBranchName] //重新命名分支 git taggit tag 用于创建、删除、查看标签。 12345git tag [tagName] // 新建标签git tag // 查看标签列表git tag -d [tagName] // 删除标签git push origin [tagName] // 推送标签到远程仓库 git addgit add 命令用于将本地文件添加到暂存区。 12345git add [file1] [file2] // 添加指定文件至暂存区git add [dir] // 添加指定目录至暂存区git add . // 添加当前目录下所有文件至暂存区git add -A // 添加当前仓库下的所有文件改动至暂存区 git commitgit commit 命令用于将暂存区内容添加到本地仓库中。 1234git commit -m &#x27;xxx&#x27; // 将暂存区文件添加到本地仓库，并记录下备注git commit -m &#x27;xxx&#x27; -n // 将暂存区文件添加到本地仓库，并记录下备注，同时跳过 husky hooks 设置的规则校验git commit -am &#x27;xxx&#x27; // 将文件添加到暂存区，再添加到本地仓库，并记录下备注 git pushgit push 命令用于将本地分支推送到远程仓库。 123git push [remoteName] [branchName] // 推送分支git push --set-upstream [remoteName] [branchName] // 推送分支并建立关联关系 git pullgit pull 命令用于从远程仓库拉取代码并合并到本地当前分支。 123git pull // 从远程仓库拉取代码合并到本地，等同于 git fetch &amp;&amp; git mergegit pull --rebase // 使用rebase的模式进行合并 git fetchgit fetch 命令用于从远程获取代码库。 1234git fetch // 从所有远程仓库拉取当前分支代码git fetch [remoteName] // 从指定远程仓库拉取当前分支代码git fetch --all // 获取所有远程仓库所有分支的更新 git cherry-pickgit cherry-pick 命令用于获取指定的 commit，可以将分支 a 上的 commit 1，复制到分支 b上。 12git cherry-pick [commitId] // 获取指定的commit git mergegit merge 命令用于分支合并，将其他分支的内容合并到当前分支中。 12git merge [branchName] git rebasegit rebase 用于分支变基。 12git rebase master // 将当前分支变基到 master 分支上 git rebase -i 交互模式： 12git rebase -i [commitId] // 基于 commitId 进行 rebase，交互式变基，可以重新编辑 commit，比如压缩合并 git resetgit reset 命令用于回退版本，可以指定退回某一次提交的版本。 1234567git reset HEAD^ // 回退所有内容到上一个版本git reset HEAD^ [filename] // 回退某文件到上一个版本git reset [commitId] // 回退所有内容到指定版本git reset --soft HEAD~1 // 回退本地仓库到上一个版本git reset --hard HEAD~1 // 回退本地仓库到上一个版本，并删除工作区所有未提交的修改内容复制代码 git revertgit revert 指令用于回滚提交，可以回滚某一次提交记录。 123git revert [commitId] // 回滚某次提交git revert [commitId] -m 1 // 回滚某次 merge 的 commit，1 代表保留主分支代码 git stashgit stash 用于暂存文件。 12345678git stash // 暂存文件git stash save &#x27;aa&#x27; // 暂存文件，添加备注git stash pop // 应用最近一次暂存文件，并删除暂存记录git stash apply // 应用最近一次暂存，但不删除该暂存记录git stash apply stash@&#123;第几次暂存的代码，例如0&#125; // 应用某一次暂存，但不删除该暂存记录；git stash list // 暂存记录git stash clear // 删除所有暂存记录复制代码 git refloggit reflog 记录了所有的 commit 操作记录，便于错误操作后找回。 12git reflog git rmgit rm 用于从 git 仓库删除指定文件或目录。 123git rm [filname]git rm [dir] git loggit log 命令用于查看 git commit 记录。 12git log // 查看所有 commit 记录git log --grep 瀑布流 // 搜索 commit msg 有瀑布流关键字的 记录","categories":[],"tags":[]},{"title":"","slug":"git 一般操作","date":"2023-01-16T13:53:13.892Z","updated":"2023-01-16T13:53:37.076Z","comments":true,"path":"2023/01/16/git 一般操作/","link":"","permalink":"http://example.com/2023/01/16/git%20%E4%B8%80%E8%88%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"Git global setup12git config --global user.name &quot;Administrator&quot;git config --global user.email &quot;admin@example.com&quot; Create a new repository1234567git clone ssh://git@192.168.2.2:222/root/newbeemallplus.gitcd newbeemallplusgit switch -c maintouch README.mdgit add README.mdgit commit -m &quot;add README&quot;git push -u origin main Push an existing folder123456cd existing_foldergit init --initial-branch=maingit remote add origin ssh://git@192.168.2.2:222/root/newbeemallplus.gitgit add .git commit -m &quot;Initial commit&quot;git push -u origin main Push an existing Git repository12345cd existing_repogit remote rename origin old-origingit remote add origin ssh://git@192.168.2.2:222/root/newbeemallplus.gitgit push -u origin --allgit push -u origin --tags","categories":[],"tags":[]},{"title":"","slug":"docker部署springboot项目","date":"2022-09-17T12:34:13.529Z","updated":"2022-09-17T14:25:04.647Z","comments":true,"path":"2022/09/17/docker部署springboot项目/","link":"","permalink":"http://example.com/2022/09/17/docker%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"docker部署springboot项目本文主要介绍docker如何部署springboot项目 创建一个springboot项目，打包成jar包该项目端口为8081，logback日志目录为/home/docker/logs 准备一台搭建好了docker的linux服务器linux搭建docker攻略移步：https://www.cnblogs.com/lixianguo/p/13254950.html创建/home/docker文件夹，将打包的jar包上传创建/home/docker/logs文件夹存放日志文件，该路径与项目中logback中设置的一致创建Dockerfile,内容如下 12345678910#指定基础镜像，不需要另外安装jdkFROM java:8#维护者MAINTAINER lxg#将本地文件添加到容器中，并更名为myproject.jarCOPY springboot-docker-1.0-SNAPSHOT.jar myproject.jar#指定访问端口，与yml文件中的端口一致EXPOSE 8081#容器启动时，运行该程序ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;myproject.jar&quot;] 目录截图如下 使用命令构建镜像最后空格和”.”不可忽略 1docker build -t myproject . 创建并启动容器123docker run -p 8080:8081 --name myproject \\&gt; -v /home/docker/logs:/home/docker/logs \\&gt; -d myproject 8080是外界访问的端口，可以自定义，8081是Dockerfile中定义的端口。-v是为了将容器中的日志目录挂载出来，冒号之前是linux宿主机自己创建的目录，可以自定义。后面的是logback文件中定义的输出日志的目录。","categories":[],"tags":[]},{"title":"","slug":"lamdba表达式的运用总结","date":"2022-08-26T06:22:39.859Z","updated":"2022-08-26T06:40:21.434Z","comments":true,"path":"2022/08/26/lamdba表达式的运用总结/","link":"","permalink":"http://example.com/2022/08/26/lamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%BF%90%E7%94%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"lambda表达式总结（集合操作）1.集合的排序123456Comparator&lt;Hero&gt; comparator=new Comparator&lt;Hero&gt;() &#123; @Override public int compare(Hero o1, Hero o2) &#123; return o1.getHp()-o2.getHp(); &#125;&#125;; 先写一个comparator,根据age排序 然后调用 1List&lt;Hero&gt; sortHeroList=heroList.stream().sorted(comparator).collect(Collectors.toList()); 2.最大最小值的属性以及具体元素1Hero maxAgeHero=heroList.stream().max(comparator).get(); 3.去重一般去重1List&lt;Hero&gt; heroeDistinct=heroList.stream().distinct().collect(Collectors.toList()); 4.求和一般求和1int sum=heroList.stream().mapToInt(Hero::getHp).sum(); 大数类求和 1BigDecimal totalQuantity = bigDecimalList.stream().map(Hero::getHp).reduce(BigDecimal.ZERO,BigDecimal::add); 5.分组根据某个属性分组并且转成Map&lt;String,List&gt; 1Map&lt;String,List&lt;Hero&gt;&gt; groupMap=heroList.stream().collect(Collectors.groupingBy(Hero::getSex)); 6.list转为map12//list转为map,如果重复，则取k1的值Map&lt;Integer,Hero&gt; heroMap=heroList.stream().collect(Collectors.toMap(Hero::getHp,a-&gt;a,(k1,k2)-&gt;k1)); 7. 新的list12//获取某个值转为新的listList&lt;Integer&gt; heroAgeList=heroList.stream().map(a-&gt;a.getHp()).collect(Collectors.toList()); 8.过滤1List&lt;Hero&gt; heroList1=heroList.stream().filter(hero -&gt; hero.getHp()&lt;300&amp;&amp;hero.getHp()&gt;100).collect(Collectors.toList()); 总结表达式主要分为中间过程和结束操作 零个或多个中间操作： 每个中间操作会返回一个流，如filter,中间操作时懒操作，不会真正遍历​ 中间操作有很多种，主要分为两种： ​ 1.对元素进行筛选：filter（匹配），distinct（去除重复）,sorted（自然排序） ​ sorted(Comparator)（指定排序），limit（保留），skip（忽略） ​ 2.转为其他形式的流：mapToDouble（转为double的流）, map（转换为任意类型的流） 结束操作： 例如forEach，会返回非流结果，例如基本类型的值（int,float,double）、对象或者集合，或者在终端操作为forEach的情况下没有返回值。​ 结束操作时才真正进行遍历行为，前面的中间操作也在这个时候真正的执行。 ​ 常见的结束操作如下： ​ forEach()（遍历每个元素），toArray()（转换为数组），min(Comparator)（取最小的元素） ​ max(Comparator)（取最大的元素），count()（总数），findFirst()（第一个元素）.get(). 以及Collectors.toList()转为list","categories":[],"tags":[]},{"title":"","slug":"dockers部署jenkins和gitlab总结","date":"2022-08-22T01:14:42.339Z","updated":"2023-02-14T01:40:43.571Z","comments":true,"path":"2022/08/22/dockers部署jenkins和gitlab总结/","link":"","permalink":"http://example.com/2022/08/22/dockers%E9%83%A8%E7%BD%B2jenkins%E5%92%8Cgitlab%E6%80%BB%E7%BB%93/","excerpt":"","text":"docker部署jenkins和gitlab总结jenkins安装1拉取docker镜像并启动docker pull jenkinsci/blueoceandocker run -e JAVA_OPTS=”-Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true” –name jenkins -u root –rm -d -p 7005:8080 -p 50000:50000 -v /data/service/jenkins:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v /data/service/apache-maven-3.8.5:/usr/local/maven -v /data/service/jdk1.8.0_212:/usr/local/jdk jenkinsci/blueocean 注意，这里的run -e JAVA_OPTS=”-Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true” –name 是用来允许跨网站请求伪造，方便后来部署webhook –rm代表stop容器后就删除了容器 -v代表挂载，这里分别挂载jenkins目录，maven目录，jdk目录 -name代表容器名是jenkens ，这个可以直接通过docker rm Jenkins就删除了jenkins目录 -p代表端口映射，这里是代表容器在7005端口启动 启动后访问 ip:7005 2查看密码登录查看密码 ，目录文件为/data/service/Jenkins cat /data/service/jenkins/secrets/initialAdminPassword 3配置环境变量和git设置全局工作变量 ，git和java是有的，不用配置 这里只用配置maven环境变量，地址是docker容器内的 首先生成公钥 进入jinkins容器后执行 docker exec -it jenkins bash ssh-keygen -t rsa -C ‘&#49;&#x35;&#48;&#49;&#57;&#x34;&#x37;&#x34;&#x39;&#53;&#x31;&#x40;&#49;&#x36;&#x33;&#x2e;&#99;&#111;&#x6d;’ cat ~/.ssh/id_rsa.pub 将公钥填入 新建一个自由风格项目 这里将刚才的公钥填入 4安装ssh插件并执行远程ssh连接搜索 Publish over SSH 插件安装，搜索 Maven Integration 插件安装 在系统设置下配置远程连接，这里我配置主机地址,找到Publish over SSH 接着构建项目 主要流程是先打包项目，然后把git目录下的项目的包发送 这里首先是Soure set这里代表git根目录下的地址 remove prefix代表去除项目前缀，可以不配置 关键是remote directory 这里是用户的目录地址下的，这是个坑，即如果是root目录，则是/root/data/test，即用户打包的东西会传到这个目录下 这里的shell命令就是删除原来的进程然后构建 webhook配置webhook配置\\1. 安装Generic Webhook Trigger插件 \\2. 加入git的公钥到jenkins \\3. 生成key ssh-keygen -t rsa -C ‘&#x31;&#x35;&#x31;&#x37;&#x32;&#53;&#51;&#55;&#48;&#52;&#x39;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#109;‘ cat ~/.ssh/id_rsa.pub \\4. 将构建触发器勾上! \\5. 配置apitoken，这里是后面APItoken的地址 这里是在用户配置哪里，点设置，进去之后就能看到apitoken 先找到设置然后打勾 \\1. 找到WebHooks配置界面，在POST地址框中输入如下格式内容： \\2. \\3. http://:@&lt;Jenkins IP地址&gt;:端口/generic-webhook-trigger/invoke \\4. 添加url http://root:1148e42061461a8d68883794319c3dcd82@192.168.2.2:7005/generic-webhook-trigger/invoke 配置gitlab拉docker 并启动docker pull gitlab/gitlab-cedocker run -d -p 443:443 -p 81:80 -p 222:22 –name gitlab –restart always -v /root/gitlab/config:/etc/gitlab -v /root/gitlab/logs:/var/log/gitlab -v /root/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce 配置启动路径gitlab.rb文件内容默认全是注释 $ vim /root/gitlab/config/gitlab.rb 配置http协议所使用的访问地址,不加端口号默认为80 external_url ‘http://192.168.2.7&#39; external_url ‘http://120.77.247.123&#39; 配置ssh协议所使用的访问地址和端口 gitlab_rails[‘gitlab_ssh_host’] = ‘192.168.2.7 ‘gitlab_rails[‘gitlab_shell_ssh_port’] = 222 # 此端口是run时22端口映射的222端口:wq #保存配置文件并退出重启gitlab容器 $ docker restart gitlabGitLab占用内存非常恐怖，解决方法很简单 修改/root/gitlab/config/gitlab/gitlab.rb 文件，将 unicorn[‘worker_processes’] = 2 去掉注释就可以了。在注释的情况下默认是服务器上的所有线程。 重置root密码docker exec -it gitlab /bin/bash启用docker里面gitlab的ruby 注意，这里一定要等到控制台打印信息后才能输入下面的usergitlab-rails console -e production 找到管理员用户user = User.where(id: 1).first 更改密码user.password = ‘abcd1234’user.password_confirmation = ‘abcd1234’记得保存user.save! ​","categories":[],"tags":[]},{"title":"","slug":"部署ruoyi前后端分离版","date":"2022-08-18T09:29:31.771Z","updated":"2022-08-18T09:43:00.936Z","comments":true,"path":"2022/08/18/部署ruoyi前后端分离版/","link":"","permalink":"http://example.com/2022/08/18/%E9%83%A8%E7%BD%B2ruoyi%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%89%88/","excerpt":"","text":"部署ruoyi前后端分离版此步骤在不分离版后延续redis启动docker pull redis:latestdocker run -d –rm -v /root/redis/data:/data –name redis -p 6379:6379 redis redis-server –appendonly yes nodejscd /data/tmptar -zxvf node-v14.15.5-linux-x64.tar.gzmv node-v14.15.5-linux-x64 /data/servicecd /data/servicell配置环境变量vim /etc/profileexport NODEJS_HOME=/data/service/node-v14.15.5-linux-x64export PATH=$PATH:$NODEJS_HOME/binsource /etc/profile nginxcd /data/tmptar zxvf nginx-1.18.0.tar.gzcd nginx-1.18.0./configure –prefix=/data/service/ngnixmake &amp;&amp; make install/data/service/ngnix/sbin/nginx git拉代码并修改配置文件，打包cd /data/giteegit clone &#x67;&#105;&#116;&#x40;&#x67;&#105;&#x74;&#101;&#101;&#x2e;&#99;&#111;&#109;:y_project/RuoYi-Vue.gitcd /data/gitee/RuoYi-Vue/ruoyi-admin/src/main/resources/#修改application.yml的项目启动端口号与文件上传路径vim application.yml#修改application-druid.yml的数据源vim application-druid.ymlcd /data/gitee/RuoYi-Vue/mvn clean install -pl com.ruoyi:ruoyi-admin -ammkdir -p /data/app/ruoyi-vuecp /data/gitee/RuoYi-Vue/ruoyi-admin/target/ruoyi-admin.jar /data/app/ruoyi-vue/ruoyi-admin.jarcd /data/app/ruoyi-vue/#后台启动项目nohup java -jar ruoyi-admin.jar &amp;#查看项目运行日志tail -f nohup.out 启动前端项目1、下载依赖并打包cd /data/gitee/RuoYi-Vue/ruoyi-uinpm install –registry=https://registry.npmmirror.comnpm installmkdir /data/app/ruoyi-uimv dist/* /data/app/ruoyi-ui/ 配置nginx此处/代表根目录 root配置的dist的明确地址 /prod-api/配置的是转发路径，及前端请求都转发到 localhost:18081地址 ​ location / {​ root /data/app/ruoyi-ui/dist; 此处为前端dist路径​ index index.html index.htm;​ }​ location /prod-api/ { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://localhost:18081/; 此处为后端项目路径}重启nginx/data/service/ngnix/sbin/nginx -s reload访问 192.168.2..6:80","categories":[],"tags":[]},{"title":"","slug":"部署ruoyi前后端不分离版","date":"2022-08-18T08:51:40.113Z","updated":"2022-08-18T09:29:05.448Z","comments":true,"path":"2022/08/18/部署ruoyi前后端不分离版/","link":"","permalink":"http://example.com/2022/08/18/%E9%83%A8%E7%BD%B2ruoyi%E5%89%8D%E5%90%8E%E7%AB%AF%E4%B8%8D%E5%88%86%E7%A6%BB%E7%89%88/","excerpt":"","text":"部署ruoyi前后端不分离版项目目录 #tmp存放临时安装包mkdir -p /data/tmp#service存放软件环境mkdir -p /data/service#gitee存放代码版本控制库mkdir -p /data/gitee 安装javajavacd /data/tmptar -zxvf jdk-8u212-linux-x64.tar.gzmv jdk1.8.0_212 /data/servicecd /data/servicellvim /etc/profileexport JAVA_HOME=/data/service/jdk1.8.0_212export PATH=$PATH:$JAVA_HOME/binsource /etc/profile 安装mavencd /data/tmptar -zxvf apache-maven-3.8.5-bin.tar.gzmv apache-maven-3.8.5 /data/servicecd /data/servicellvim /etc/profileexport MAVEN_HOME=/data/service/apache-maven-3.8.5export PATH=$PATH:$MAVEN_HOME/binsource /etc/profilevim /data/service/apache-maven-3.8.5/conf/setting.xml#配置本地仓库/data/service/apache-maven-3.8.5/repository#配置阿里云镜像 aliyunmaven * 阿里云公共仓库 https://maven.aliyun.com/repository/public 安装gityum -y groupinstall “Development Tools”yum install wget unzip gettext-devel openssl-devel perl-CPAN perl-devel zlib-devel libcurl-devel expat-devel -ycd /data/tmptar zxvf git-2.18.0.tar.gzcd git-2.18.0./configure –prefix=/data/service/gitmake &amp;&amp; make installvim /etc/profileexport GIT_HOME=/data/service/gitexport PATH=$PATH:$GIT_HOME/binsource /etc/profile git公钥，和下载项目git密匙ssh-keygen -t rsa -C “&#49;&#53;&#x31;&#55;&#50;&#53;&#x33;&#55;&#48;&#x34;&#x39;&#64;&#49;&#x36;&#51;&#x2e;&#99;&#111;&#109;“cat ~/.ssh/id_rsa.pub//粘到公匙ssh -T &#x67;&#105;&#x74;&#64;&#103;&#x69;&#x74;&#101;&#101;&#x2e;&#x63;&#111;&#x6d;cd /data/giteegit clone &#103;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#x65;&#101;&#x2e;&#x63;&#111;&#x6d;:y_project/RuoYi.git docker安装docker安装sudo yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-enginesudo yum install -y yum-utils device-mapper-persistent-data lvm2sudo yum-config-manager –add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repoyum install -y https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/edge/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpmyum install docker-ce docker-ce-cli -ysudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-‘EOF’{ “registry-mirrors”: [“https://plb9xzjh.mirror.aliyuncs.com&quot;]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker mysql安装docker pull mysql:5.7.30mkdir -p /root/mysql/data /root/mysql/logs /root/mysql/conftouch /root/mysql/conf/my.cnf//密码是admin，-v则是挂载 –name容器名字，作为后面的启动删除名字docker run -p 3306:3306 –rm –name mysql -v /root/mysql/conf:/etc/mysql/conf.d -v /root/mysql/logs:/var/log/mysql -v /root/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=admin -d mysql:5.7.30docker start mysql//进入容器docker exec -it mysql /bin/bash#登录docker容器（方式参考上方文档）后登录mysqlmysql -uroot -padmin#修改登录者的权限GRANT ALL ON . TO ‘root‘@’%’;#刷新命令生效 flush privileges; 修改项目配置cd /data/gitee/RuoYi/ruoyi-admin/src/main/resources/#修改application.yml的项目启动端口号与文件上传路径vim application.yml#修改application-druid.yml的数据源vim application-druid.yml 打包启动cd /data/gitee/RuoYi/mvn installmkdir -p /data/app/ruoyi-admincp /data/gitee/RuoYi/ruoyi-admin/target/ruoyi-admin.jar /data/app/ruoyi-admin/ruoyi-admin.jarcd /data/app/ruoyi-admin/#后台启动项目nohup java -jar ruoyi-admin.jar &amp;#查看项目运行日志tail -f nohup.out 开放端口重启防火墙firewall-cmd –permanent –add-port=80/tcpfirewall-cmd –reload","categories":[],"tags":[]},{"title":"","slug":"回溯，双指针，和栈的运用","date":"2022-07-25T02:59:38.180Z","updated":"2022-07-25T03:35:30.960Z","comments":true,"path":"2022/07/25/回溯，双指针，和栈的运用/","link":"","permalink":"http://example.com/2022/07/25/%E5%9B%9E%E6%BA%AF%EF%BC%8C%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%8C%E5%92%8C%E6%A0%88%E7%9A%84%E8%BF%90%E7%94%A8/","excerpt":"","text":"回溯，双指针，和栈的个人总结1.回溯给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1：输入：candidates = [2,3,6,7], target = 7, 个人思路总结常规回溯，回溯的下一次target为 target-candidates【i】，首先将数组排序，每次回溯时候，当target-candidate[i]&lt;0时候，则终止回溯，剪枝干。当target==0时候，则保留结果。注意结果不重复，则每次是以begin开始。 代码如下 2.双指针 给定n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 个人思路总结我们可以按照分列的思路解，遍历每一列，第一列，最后一列，不积水，跳过，第二列开始，每列积水高度由该列左边最高列，右边最高列中最短的列减去该列高度决定，如果该值小于零，则舍弃，大于零，则累加。 代码如下 3.栈的运用给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: “()” 输出: true 示例 2: 输入: “()[]{}” 输出: true 个人思路如果遇到左括号，则将右括号入栈。如果是右括号，则判断是不是和栈顶弹出的元素相同，如果不相同则false，如果相同则弹出，如果栈为空 则直接false，因为此时后面都是弹出的。 代码","categories":[],"tags":[]},{"title":"","slug":"算法-回溯总结","date":"2022-07-15T14:11:42.844Z","updated":"2022-07-15T14:18:56.333Z","comments":true,"path":"2022/07/15/算法-回溯总结/","link":"","permalink":"http://example.com/2022/07/15/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93/","excerpt":"","text":"回溯总结题目给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例:输入：”23”输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. 个人思路可以维护一个2-9对应字母的数组，为String[] numsString={“”, “”, “abc”, “def”, “ghi”, “jkl”, “mno”, “pqrs”, “tuv”, “wxyz”}; 则2-9分别有了对应关系，用dfs(String digits,int nums,String[] numsString)表示从下表nums开始回溯，则终止条件为nums==digits.length()，获取每个数字对应的temp，遍历temp，下标加一进行回溯，最后要移除最后一个字母 代码如下","categories":[],"tags":[]},{"title":"","slug":"算法-双指针和hashmap的运用","date":"2022-07-14T08:26:47.912Z","updated":"2022-07-14T08:53:08.827Z","comments":true,"path":"2022/07/14/算法-双指针和hashmap的运用/","link":"","permalink":"http://example.com/2022/07/14/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88%E5%92%8Chashmap%E7%9A%84%E8%BF%90%E7%94%A8/","excerpt":"","text":"算法-双指针和hashmap的运用1.两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 个人思路遍历数组，计算和目标的差额temp，并把数组放入hashmap，调用hashmap.put(nums[i],i)方法，如果hashmap中包含temp这个key，则是一种答案 2.最长回文子串给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 输入：s = “babad” 输出：”bab” 解释：”aba” 同样是符合题意的答案。 个人思路遍历字符串，每种i代表以什么为中心，分两种情况，一种是一个字符为中心朝两边扩展 ，如“bab”，中心是a，第二种是以两个字符为中心像两边扩展，如“baab”，中心是aa，创建extend（String s,int start,int end）方法，其中start，end方法代表字符截取的下标，如果s.chartAT(start)==s.chartAT(end)则start–，end++，最后返回最长的那个即是答案。 3.三数之和给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意： 答案中不可以包含重复的三元组。 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 个人思路遍历 字符串，i下表表示第一个数字索引，剩下两个两个数一个为i+1，一个为length-1，如果 nums【i】+nums【left】+nums【right】大于0，则 right–，否则left++；如果等于0，则right–，left++；另外等于0时候，则要考虑重复，如果这个 nums【right】==nums【right+1】则right–，就会去除重复","categories":[],"tags":[]},{"title":"","slug":"token的一点个人总结","date":"2022-07-08T15:12:08.053Z","updated":"2022-07-08T15:33:28.646Z","comments":true,"path":"2022/07/08/token的一点个人总结/","link":"","permalink":"http://example.com/2022/07/08/token%E7%9A%84%E4%B8%80%E7%82%B9%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/","excerpt":"","text":"token的个人总结token的组成1.header 元数据，定义token的类型和加密算法 2.payload token的具体数据，比如userid就是放在payload中 3.sign 签名 服务器通过Payload、Header和一个密钥(secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。 生成token方法调用 jwt.creat()方法生成，具体如下，先用SHA256算法将sercret加密，放入sign中，将userid放入payload中，定义header的加密算法和token类型 解析token方法，并获取userid主要是先根据sign获取到JWTVerifier对象，再获取DecodeJwt对象，最后将payload中uerid取出 总之，token是根据签名的加密算法生成sign，再根据sign反解析得到JWTVerifier，并可以把userid放入clamims中 token的一些好处1.无状态 2.有效避免了CSRF 攻击（大部分情况下存放在 local storage ）","categories":[],"tags":[]},{"title":"","slug":"Redis持久化机制","date":"2022-07-07T12:45:30.724Z","updated":"2022-07-07T12:49:04.246Z","comments":true,"path":"2022/07/07/Redis持久化机制/","link":"","permalink":"http://example.com/2022/07/07/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Redis 持久化机制很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。 Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。 快照（snapshotting）持久化（RDB） Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。 快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置： 12345save 900 1 #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。save 300 10 #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。save 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。 AOF（append-only file）持久化 与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启： 1appendonly yes 1 开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 server.aof_buf 中，然后再根据 appendfsync 配置来决定何时将其同步到硬盘中的 AOF 文件。 AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。 在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：appendfsync always #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度appendfsync everysec #每秒钟同步一次，显式地将多个写命令同步到硬盘appendfsync no #让操作系统决定何时进行同步","categories":[],"tags":[]},{"title":"","slug":"ThreadPoolExecutor 类分析","date":"2022-07-07T11:59:47.199Z","updated":"2022-07-07T12:25:56.716Z","comments":true,"path":"2022/07/07/ThreadPoolExecutor 类分析/","link":"","permalink":"http://example.com/2022/07/07/ThreadPoolExecutor%20%E7%B1%BB%E5%88%86%E6%9E%90/","excerpt":"","text":"线程池总结ThreadPoolExecutor 3 个最重要的参数： corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。 maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。 workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。 线程池的执行策略 线程池和callable一起使用，一般用来有返回值得类型第一 创建线程池 1private static ThreadPoolExecutor executorService = new ThreadPoolExecutor(9, 9, 1000, TimeUnit.MILLISECONDS, WORK_QUEUE, HANDLER); ​ 第二 重写callable方法 ​ Callable bannerListCallable = () -&gt; adService.queryIndex(); ​ 第三步 调用线程池submit方法，获取future对象 ​ Future banner=executorService.submit(bannerListCallable); ​ 第四步，调用future.get方法获取返回值 ​ Map&lt;String, Object&gt; entity = new HashMap&lt;&gt;(); ​ entity.put(“banner”, banner.get());","categories":[],"tags":[]},{"title":"","slug":"递归的一点思考","date":"2022-07-07T11:11:15.948Z","updated":"2022-07-07T12:26:34.949Z","comments":true,"path":"2022/07/07/递归的一点思考/","link":"","permalink":"http://example.com/2022/07/07/%E9%80%92%E5%BD%92%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/","excerpt":"","text":"递归的一点思考递归就是将大问题转化为小问题的一种思路。 它有两个特点， 1.重复调用自身函数 2.有终结条件 例如leetcode题目二叉树的中序遍历就可用递归","categories":[],"tags":[]},{"title":"","slug":"若依项目前后端分离部署","date":"2022-06-15T08:32:27.658Z","updated":"2022-07-07T12:27:57.561Z","comments":true,"path":"2022/06/15/若依项目前后端分离部署/","link":"","permalink":"http://example.com/2022/06/15/%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%83%A8%E7%BD%B2/","excerpt":"","text":"若依项目前后端分离部署启动防火墙 systemctl start firewalld 端口占用netstat -npl | grep “80” #开放端口 firewall-cmd –permanent –add-port=3306/tcp #重启防火墙firewall-cmd –reload #mysql安装docker pull mysql:5.7.30mkdir -p /root/mysql/data /root/mysql/logs /root/mysql/conftouch /root/mysql/conf/my.cnf//密码是admin，-v则是挂载 –name容器名字，作为后面的启动删除名字docker run -p 3306:3306 –rm –name mysql -v /root/mysql/conf:/etc/mysql/conf.d -v /root/mysql/logs:/var/log/mysql -v /root/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=admin -d mysql:5.7.30docker start mysql //进入容器docker exec -it mysql /bin/bash登录docker容器（方式参考上方文档)后登录mysqlmysql -uroot -padmin修改登录者的权限GRANT ALL ON . TO ‘root‘@’%’;#刷新命令生效 flush privileges; #重启mysql //docker rm mysqldocker run -p 3306:3306 –rm –name mysql -v /root/mysql/conf:/etc/mysql/conf.d -v /root/mysql/logs:/var/log/mysql -v /root/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=admin -d mysql:5.7.30重启redis//docker run -d –rm -v /root/redis/data:/data –name redis -p 6379:6379 redis redis-server –appendonly yes 重启nginx/data/service/ngnix/sbin/nginx -s reload 重启nginx // cd /data/tmpmake install/data/service/ngnix/sbin/nginx #Jenkins安装docker pull jenkinsci/blueoceandocker run –name jenkins -u root –rm -d -p 7005:8080 -p 50000:50000 -v /data/service/jenkins:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v /data/service/apache-maven-3.8.5:/usr/local/maven -v /data/service/jdk1.8.0_212:/usr/local/jdk jenkinsci/blueocean-u root：以 root 权限启动，防止出现权限问题-p 7005:8080：端口映射，服务器的 7005 端口映射容器的 8080 端口-p 50000:50000：Jenkins代理默认通过TCP端口50000与Jenkins主机通信-v /data/jenkins:/var/jenkins_home：把容器内的 Jenkins 目录挂载到服务器的 /data/jenkins 目录以防容器没了，数据也没了-v /var/run/docker.sock:/var/run/docker.sock：保证容器内的 docker 与 服务器上 docker 的通讯 附带下删除 jenkinsci/blueocean 容器 删除对应绑定网桥docker network disconnect –force bridge jenkinsci-blueocean 删除 jenkinsci-blueocean 容器，xxxx 容器 IDdocker rm -f xxxx查看密码 ，目录文件为/data/service/Jenkinscat /data/service/jenkins/secrets/initialAdminPasswordJenkisn部署项目 1.全局工作配置这里的java_home 路劲是docker挂载 路径，这里的maven路进是挂载路径注意：只用修改java和maven，git是已经有的2.插件安装搜索 Publish over SSH 插件安装，搜索 Maven Integration 插件安装3.ssh连接在系统设置下配置远程连接，这里我配置主机地址4.进入git项目配置 首先生成公钥进入jinkins容器后执行Docker exec -it dockerid bashssh-keygen -t rsa -C ‘&#49;&#x35;&#x30;&#x31;&#x39;&#x34;&#55;&#52;&#x39;&#53;&#x31;&#x40;&#49;&#54;&#x33;&#x2e;&#x63;&#x6f;&#x6d;’cat ~/.ssh/id_rsa.pub将公钥粘入gitee 在安全认证中把公钥加入5，进入项目配置悬念则git仓库，选择刚才配置公钥 .选择6.选择ssh接入下面的shell如下cd /root/data/testid=$(ps -ef | grep “ruoyi-admin.jar” | grep -v grep| awk ‘{print $2}’)echo $idkill -9 $idnohup /data/service/jdk1.8.0_212/bin/java -jar ruoyi-admin.jar &gt;myout.log 2&gt;&amp;1 &amp;注意，这里一定要指定java执行路径 这里是/data/service/jdk1.8.0_212/bin/java，这是个大坑, 这里的远程目录是在/root下，即如果配置/data/test,则最终路径是在/root/data/test部署gitlabdocker pull gitlab/gitlab-cedocker run -d -p 443:443 -p 80:80 -p 222:22 –name gitlab –restart always -v /root/gitlab/config:/etc/gitlab -v /root/gitlab/logs:/var/log/gitlab -v /root/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce gitlab.rb文件内容默认全是注释$ vim /root/gitlab/config/gitlab.rb 配置http协议所使用的访问地址,不加端口号默认为80external_url ‘http://192.168.2.2&#39; 配置ssh协议所使用的访问地址和端口gitlab_rails[‘gitlab_ssh_host’] = ‘192.168.2.2 ‘gitlab_rails[‘gitlab_shell_ssh_port’] = 222 # 此端口是run时22端口映射的222端口:wq #保存配置文件并退出重启gitlab容器$ docker restart gitlab重置root密码docker exec -it gitlab（容器名字） /bin/bash启用docker里面gitlab的rubygitlab-rails console -e production 找到管理员用户user = User.where(id: 1).first 更改密码user.password = ‘abcd1234’user.password_confirmation = ‘abcd1234’记得保存user.save! webhook配置 安装Generic Webhook Trigger插件 加入git的公钥到jenkins 生成key ssh-keygen -t rsa -C ‘&#49;&#53;&#49;&#55;&#50;&#x35;&#x33;&#x37;&#x30;&#52;&#x39;&#64;&#49;&#54;&#51;&#x2e;&#x63;&#x6f;&#109;‘ cat ~/.ssh/id_rsa.pub 配置apitoken，这里是后面APItoken的地址6. 允许本地访问该地址 在menu-admin-setting-network7.8. 找到WebHooks配置界面，在POST地址框中输入如下格式内容：9.10. http://:@&lt;Jenkins IP地址&gt;:端口/generic-webhook-trigger/invoke11. 添加urlhttp://root:1148e42061461a8d68883794319c3dcd82@192.168.2.2:7005/generic-webhook-trigger/invoke 配置固定ip地址虚拟机安装Linux系列教材 （八）- 设置 Centos7 为固定ip地址 (how2j.cn)需要注意编写ens33时候 onboot=yes如果出现报错”Could not resolve host: mirrorlist.centos.org; Unknown error”则在”Could not resolve host: mirrorlist.centos.org; Unknown error”解决方法 - Mr.Gavin - 博客园 (cnblogs.com)处理 Ipv4转发（连接不上数据库）2.开启转发配置 vim /etc/sysctl.conf #配置转发net.ipv4.ip_forward=1#保存退出就可以了:wq!#重启服务，让配置生效systemctl restart network","categories":[],"tags":[]}],"categories":[],"tags":[]}