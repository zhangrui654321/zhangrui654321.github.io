{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"算法-双指针和hashmap的运用","date":"2022-07-14T08:26:47.912Z","updated":"2022-07-14T08:53:08.827Z","comments":true,"path":"2022/07/14/算法-双指针和hashmap的运用/","link":"","permalink":"http://example.com/2022/07/14/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88%E5%92%8Chashmap%E7%9A%84%E8%BF%90%E7%94%A8/","excerpt":"","text":"算法-双指针和hashmap的运用1.两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 个人思路遍历数组，计算和目标的差额temp，并把数组放入hashmap，调用hashmap.put(nums[i],i)方法，如果hashmap中包含temp这个key，则是一种答案 2.最长回文子串给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 输入：s = “babad” 输出：”bab” 解释：”aba” 同样是符合题意的答案。 个人思路遍历字符串，每种i代表以什么为中心，分两种情况，一种是一个字符为中心朝两边扩展 ，如“bab”，中心是a，第二种是以两个字符为中心像两边扩展，如“baab”，中心是aa，创建extend（String s,int start,int end）方法，其中start，end方法代表字符截取的下标，如果s.chartAT(start)==s.chartAT(end)则start–，end++，最后返回最长的那个即是答案。 3.三数之和给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意： 答案中不可以包含重复的三元组。 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 个人思路遍历 字符串，i下表表示第一个数字索引，剩下两个两个数一个为i+1，一个为length-1，如果 nums【i】+nums【left】+nums【right】大于0，则 right–，否则left++；如果等于0，则right–，left++；另外等于0时候，则要考虑重复，如果这个 nums【right】==nums【right+1】则right–，就会去除重复","categories":[],"tags":[]},{"title":"","slug":"token的一点个人总结","date":"2022-07-08T15:12:08.053Z","updated":"2022-07-08T15:33:28.646Z","comments":true,"path":"2022/07/08/token的一点个人总结/","link":"","permalink":"http://example.com/2022/07/08/token%E7%9A%84%E4%B8%80%E7%82%B9%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/","excerpt":"","text":"token的个人总结token的组成1.header 元数据，定义token的类型和加密算法 2.payload token的具体数据，比如userid就是放在payload中 3.sign 签名 服务器通过Payload、Header和一个密钥(secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。 生成token方法调用 jwt.creat()方法生成，具体如下，先用SHA256算法将sercret加密，放入sign中，将userid放入payload中，定义header的加密算法和token类型 解析token方法，并获取userid主要是先根据sign获取到JWTVerifier对象，再获取DecodeJwt对象，最后将payload中uerid取出 总之，token是根据签名的加密算法生成sign，再根据sign反解析得到JWTVerifier，并可以把userid放入clamims中 token的一些好处1.无状态 2.有效避免了CSRF 攻击（大部分情况下存放在 local storage ）","categories":[],"tags":[]},{"title":"","slug":"Redis持久化机制","date":"2022-07-07T12:45:30.724Z","updated":"2022-07-07T12:49:04.246Z","comments":true,"path":"2022/07/07/Redis持久化机制/","link":"","permalink":"http://example.com/2022/07/07/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Redis 持久化机制很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。 Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。 快照（snapshotting）持久化（RDB） Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。 快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置： 12345save 900 1 #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。save 300 10 #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。save 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。 AOF（append-only file）持久化 与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启： 1appendonly yes 1 开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 server.aof_buf 中，然后再根据 appendfsync 配置来决定何时将其同步到硬盘中的 AOF 文件。 AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。 在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：appendfsync always #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度appendfsync everysec #每秒钟同步一次，显式地将多个写命令同步到硬盘appendfsync no #让操作系统决定何时进行同步","categories":[],"tags":[]},{"title":"","slug":"ThreadPoolExecutor 类分析","date":"2022-07-07T11:59:47.199Z","updated":"2022-07-07T12:25:56.716Z","comments":true,"path":"2022/07/07/ThreadPoolExecutor 类分析/","link":"","permalink":"http://example.com/2022/07/07/ThreadPoolExecutor%20%E7%B1%BB%E5%88%86%E6%9E%90/","excerpt":"","text":"线程池总结ThreadPoolExecutor 3 个最重要的参数： corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。 maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。 workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。 线程池的执行策略 线程池和callable一起使用，一般用来有返回值得类型第一 创建线程池 1private static ThreadPoolExecutor executorService = new ThreadPoolExecutor(9, 9, 1000, TimeUnit.MILLISECONDS, WORK_QUEUE, HANDLER); ​ 第二 重写callable方法 ​ Callable bannerListCallable = () -&gt; adService.queryIndex(); ​ 第三步 调用线程池submit方法，获取future对象 ​ Future banner=executorService.submit(bannerListCallable); ​ 第四步，调用future.get方法获取返回值 ​ Map&lt;String, Object&gt; entity = new HashMap&lt;&gt;(); ​ entity.put(“banner”, banner.get());","categories":[],"tags":[]},{"title":"","slug":"递归的一点思考","date":"2022-07-07T11:11:15.948Z","updated":"2022-07-07T12:26:34.949Z","comments":true,"path":"2022/07/07/递归的一点思考/","link":"","permalink":"http://example.com/2022/07/07/%E9%80%92%E5%BD%92%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/","excerpt":"","text":"递归的一点思考递归就是将大问题转化为小问题的一种思路。 它有两个特点， 1.重复调用自身函数 2.有终结条件 例如leetcode题目二叉树的中序遍历就可用递归","categories":[],"tags":[]},{"title":"","slug":"若依项目前后端分离部署","date":"2022-06-15T08:32:27.658Z","updated":"2022-07-07T12:27:57.561Z","comments":true,"path":"2022/06/15/若依项目前后端分离部署/","link":"","permalink":"http://example.com/2022/06/15/%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%83%A8%E7%BD%B2/","excerpt":"","text":"若依项目前后端分离部署启动防火墙 systemctl start firewalld 端口占用netstat -npl | grep “80” #开放端口 firewall-cmd –permanent –add-port=3306/tcp #重启防火墙firewall-cmd –reload #mysql安装docker pull mysql:5.7.30mkdir -p /root/mysql/data /root/mysql/logs /root/mysql/conftouch /root/mysql/conf/my.cnf//密码是admin，-v则是挂载 –name容器名字，作为后面的启动删除名字docker run -p 3306:3306 –rm –name mysql -v /root/mysql/conf:/etc/mysql/conf.d -v /root/mysql/logs:/var/log/mysql -v /root/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=admin -d mysql:5.7.30docker start mysql //进入容器docker exec -it mysql /bin/bash登录docker容器（方式参考上方文档)后登录mysqlmysql -uroot -padmin修改登录者的权限GRANT ALL ON . TO ‘root‘@’%’;#刷新命令生效 flush privileges; #重启mysql //docker rm mysqldocker run -p 3306:3306 –rm –name mysql -v /root/mysql/conf:/etc/mysql/conf.d -v /root/mysql/logs:/var/log/mysql -v /root/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=admin -d mysql:5.7.30重启redis//docker run -d –rm -v /root/redis/data:/data –name redis -p 6379:6379 redis redis-server –appendonly yes 重启nginx/data/service/ngnix/sbin/nginx -s reload 重启nginx // cd /data/tmpmake install/data/service/ngnix/sbin/nginx #Jenkins安装docker pull jenkinsci/blueoceandocker run –name jenkins -u root –rm -d -p 7005:8080 -p 50000:50000 -v /data/service/jenkins:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v /data/service/apache-maven-3.8.5:/usr/local/maven -v /data/service/jdk1.8.0_212:/usr/local/jdk jenkinsci/blueocean-u root：以 root 权限启动，防止出现权限问题-p 7005:8080：端口映射，服务器的 7005 端口映射容器的 8080 端口-p 50000:50000：Jenkins代理默认通过TCP端口50000与Jenkins主机通信-v /data/jenkins:/var/jenkins_home：把容器内的 Jenkins 目录挂载到服务器的 /data/jenkins 目录以防容器没了，数据也没了-v /var/run/docker.sock:/var/run/docker.sock：保证容器内的 docker 与 服务器上 docker 的通讯 附带下删除 jenkinsci/blueocean 容器 删除对应绑定网桥docker network disconnect –force bridge jenkinsci-blueocean 删除 jenkinsci-blueocean 容器，xxxx 容器 IDdocker rm -f xxxx查看密码 ，目录文件为/data/service/Jenkinscat /data/service/jenkins/secrets/initialAdminPasswordJenkisn部署项目 1.全局工作配置这里的java_home 路劲是docker挂载 路径，这里的maven路进是挂载路径注意：只用修改java和maven，git是已经有的2.插件安装搜索 Publish over SSH 插件安装，搜索 Maven Integration 插件安装3.ssh连接在系统设置下配置远程连接，这里我配置主机地址4.进入git项目配置 首先生成公钥进入jinkins容器后执行Docker exec -it dockerid bashssh-keygen -t rsa -C ‘&#x31;&#53;&#48;&#x31;&#57;&#x34;&#x37;&#52;&#57;&#x35;&#49;&#x40;&#49;&#x36;&#51;&#46;&#x63;&#x6f;&#109;’cat ~/.ssh/id_rsa.pub将公钥粘入gitee 在安全认证中把公钥加入5，进入项目配置悬念则git仓库，选择刚才配置公钥 .选择6.选择ssh接入下面的shell如下cd /root/data/testid=$(ps -ef | grep “ruoyi-admin.jar” | grep -v grep| awk ‘{print $2}’)echo $idkill -9 $idnohup /data/service/jdk1.8.0_212/bin/java -jar ruoyi-admin.jar &gt;myout.log 2&gt;&amp;1 &amp;注意，这里一定要指定java执行路径 这里是/data/service/jdk1.8.0_212/bin/java，这是个大坑, 这里的远程目录是在/root下，即如果配置/data/test,则最终路径是在/root/data/test部署gitlabdocker pull gitlab/gitlab-cedocker run -d -p 443:443 -p 80:80 -p 222:22 –name gitlab –restart always -v /root/gitlab/config:/etc/gitlab -v /root/gitlab/logs:/var/log/gitlab -v /root/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce gitlab.rb文件内容默认全是注释$ vim /root/gitlab/config/gitlab.rb 配置http协议所使用的访问地址,不加端口号默认为80external_url ‘http://192.168.2.2&#39; 配置ssh协议所使用的访问地址和端口gitlab_rails[‘gitlab_ssh_host’] = ‘192.168.2.2 ‘gitlab_rails[‘gitlab_shell_ssh_port’] = 222 # 此端口是run时22端口映射的222端口:wq #保存配置文件并退出重启gitlab容器$ docker restart gitlab重置root密码docker exec -it gitlab（容器名字） /bin/bash启用docker里面gitlab的rubygitlab-rails console -e production 找到管理员用户user = User.where(id: 1).first 更改密码user.password = ‘abcd1234’user.password_confirmation = ‘abcd1234’记得保存user.save! webhook配置 安装Generic Webhook Trigger插件 加入git的公钥到jenkins 生成key ssh-keygen -t rsa -C ‘&#x31;&#x35;&#x31;&#55;&#x32;&#53;&#x33;&#x37;&#x30;&#x34;&#x39;&#64;&#49;&#x36;&#51;&#x2e;&#x63;&#x6f;&#109;‘ cat ~/.ssh/id_rsa.pub 配置apitoken，这里是后面APItoken的地址6. 允许本地访问该地址 在menu-admin-setting-network7.8. 找到WebHooks配置界面，在POST地址框中输入如下格式内容：9.10. http://:@&lt;Jenkins IP地址&gt;:端口/generic-webhook-trigger/invoke11. 添加urlhttp://root:1148e42061461a8d68883794319c3dcd82@192.168.2.2:7005/generic-webhook-trigger/invoke 配置固定ip地址虚拟机安装Linux系列教材 （八）- 设置 Centos7 为固定ip地址 (how2j.cn)需要注意编写ens33时候 onboot=yes如果出现报错”Could not resolve host: mirrorlist.centos.org; Unknown error”则在”Could not resolve host: mirrorlist.centos.org; Unknown error”解决方法 - Mr.Gavin - 博客园 (cnblogs.com)处理 Ipv4转发（连接不上数据库）2.开启转发配置 vim /etc/sysctl.conf #配置转发net.ipv4.ip_forward=1#保存退出就可以了:wq!#重启服务，让配置生效systemctl restart network","categories":[],"tags":[]}],"categories":[],"tags":[]}