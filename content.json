{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"dockers部署jenkins和gitlab总结","date":"2022-08-22T01:14:42.339Z","updated":"2022-08-22T03:23:12.193Z","comments":true,"path":"2022/08/22/dockers部署jenkins和gitlab总结/","link":"","permalink":"http://example.com/2022/08/22/dockers%E9%83%A8%E7%BD%B2jenkins%E5%92%8Cgitlab%E6%80%BB%E7%BB%93/","excerpt":"","text":"docker部署jenkins和gitlab总结jenkins安装1拉取docker镜像并启动docker pull jenkinsci/blueoceandocker run -e JAVA_OPTS=”-Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true” –name jenkins -u root –rm -d -p 7005:8080 -p 50000:50000 -v /data/service/jenkins:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v /data/service/apache-maven-3.8.5:/usr/local/maven -v /data/service/jdk1.8.0_212:/usr/local/jdk jenkinsci/blueocean 注意，这里的run -e JAVA_OPTS=”-Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true” –name 是用来允许跨网站请求伪造，方便后来部署webhook –rm代表stop容器后就删除了容器 -v代表挂载，这里分别挂载jenkins目录，maven目录，jdk目录 -name代表容器名是jenkens ，这个可以直接通过docker rm Jenkins就删除了jenkins目录 -p代表端口映射，这里是代表容器在7005端口启动 启动后访问 ip:7005 2查看密码登录查看密码 ，目录文件为/data/service/Jenkins cat /data/service/jenkins/secrets/initialAdminPassword 3配置环境变量和git设置全局工作变量 ，git和java是有的，不用配置 这里只用配置maven环境变量，地址是docker容器内的 首先生成公钥 进入jinkins容器后执行 docker exec -it jenkins bash ssh-keygen -t rsa -C ‘&#49;&#x35;&#48;&#49;&#x39;&#52;&#x37;&#52;&#x39;&#x35;&#49;&#64;&#49;&#54;&#x33;&#46;&#x63;&#x6f;&#x6d;’ cat ~/.ssh/id_rsa.pub 将公钥填入 新建一个自由风格项目 这里将刚才的公钥填入 4安装ssh插件并执行远程ssh连接搜索 Publish over SSH 插件安装，搜索 Maven Integration 插件安装 在系统设置下配置远程连接，这里我配置主机地址,找到Publish over SSH 接着构建项目 主要流程是先打包项目，然后把git目录下的项目的包发送 这里首先是Soure set这里代表git根目录下的地址 remove prefix代表去除项目前缀，可以不配置 关键是remote directory 这里是用户的目录地址下的，这是个坑，即如果是root目录，则是/root/data/test，即用户打包的东西会传到这个目录下 这里的shell命令就是删除原来的进程然后构建 webhook配置webhook配置\\1. 安装Generic Webhook Trigger插件 \\2. 加入git的公钥到jenkins \\3. 生成key ssh-keygen -t rsa -C ‘&#49;&#53;&#x31;&#55;&#50;&#53;&#x33;&#55;&#48;&#52;&#57;&#64;&#x31;&#x36;&#x33;&#46;&#x63;&#111;&#x6d;‘ cat ~/.ssh/id_rsa.pub \\4. 将构建触发器勾上! \\5. 配置apitoken，这里是后面APItoken的地址 这里是在用户配置哪里，点设置，进去之后就能看到apitoken 先找到设置然后打勾 \\1. 找到WebHooks配置界面，在POST地址框中输入如下格式内容： \\2. \\3. http://:@&lt;Jenkins IP地址&gt;:端口/generic-webhook-trigger/invoke \\4. 添加url http://root:1148e42061461a8d68883794319c3dcd82@192.168.2.2:7005/generic-webhook-trigger/invoke 配置gitlab拉docker 并启动docker pull gitlab/gitlab-cedocker run -d -p 443:443 -p 80:80 -p 222:22 –name gitlab –restart always -v /root/gitlab/config:/etc/gitlab -v /root/gitlab/logs:/var/log/gitlab -v /root/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce 配置启动路径gitlab.rb文件内容默认全是注释 $ vim /root/gitlab/config/gitlab.rb 配置http协议所使用的访问地址,不加端口号默认为80 external_url ‘http://192.168.2.7&#39; 配置ssh协议所使用的访问地址和端口 gitlab_rails[‘gitlab_ssh_host’] = ‘192.168.2.7 ‘gitlab_rails[‘gitlab_shell_ssh_port’] = 222 # 此端口是run时22端口映射的222端口:wq #保存配置文件并退出重启gitlab容器 $ docker restart gitlabGitLab占用内存非常恐怖，解决方法很简单 修改/root/gitlab/config/gitlab/gitlab.rb 文件，将 unicorn[‘worker_processes’] = 2 去掉注释就可以了。在注释的情况下默认是服务器上的所有线程。 重置root密码docker exec -it gitlab（容器名字） /bin/bash启用docker里面gitlab的ruby 注意，这里一定要等到控制台打印信息后才能输入下面的usergitlab-rails console -e production 找到管理员用户user = User.where(id: 1).first 更改密码user.password = ‘abc1234’user.password_confirmation = ‘abc1234’记得保存user.save! ​","categories":[],"tags":[]},{"title":"","slug":"部署ruoyi前后端分离版","date":"2022-08-18T09:29:31.771Z","updated":"2022-08-18T09:43:00.936Z","comments":true,"path":"2022/08/18/部署ruoyi前后端分离版/","link":"","permalink":"http://example.com/2022/08/18/%E9%83%A8%E7%BD%B2ruoyi%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%89%88/","excerpt":"","text":"部署ruoyi前后端分离版此步骤在不分离版后延续redis启动docker pull redis:latestdocker run -d –rm -v /root/redis/data:/data –name redis -p 6379:6379 redis redis-server –appendonly yes nodejscd /data/tmptar -zxvf node-v14.15.5-linux-x64.tar.gzmv node-v14.15.5-linux-x64 /data/servicecd /data/servicell配置环境变量vim /etc/profileexport NODEJS_HOME=/data/service/node-v14.15.5-linux-x64export PATH=$PATH:$NODEJS_HOME/binsource /etc/profile nginxcd /data/tmptar zxvf nginx-1.18.0.tar.gzcd nginx-1.18.0./configure –prefix=/data/service/ngnixmake &amp;&amp; make install/data/service/ngnix/sbin/nginx git拉代码并修改配置文件，打包cd /data/giteegit clone &#103;&#105;&#116;&#64;&#103;&#105;&#116;&#101;&#x65;&#x2e;&#x63;&#x6f;&#x6d;:y_project/RuoYi-Vue.gitcd /data/gitee/RuoYi-Vue/ruoyi-admin/src/main/resources/#修改application.yml的项目启动端口号与文件上传路径vim application.yml#修改application-druid.yml的数据源vim application-druid.ymlcd /data/gitee/RuoYi-Vue/mvn clean install -pl com.ruoyi:ruoyi-admin -ammkdir -p /data/app/ruoyi-vuecp /data/gitee/RuoYi-Vue/ruoyi-admin/target/ruoyi-admin.jar /data/app/ruoyi-vue/ruoyi-admin.jarcd /data/app/ruoyi-vue/#后台启动项目nohup java -jar ruoyi-admin.jar &amp;#查看项目运行日志tail -f nohup.out 启动前端项目1、下载依赖并打包cd /data/gitee/RuoYi-Vue/ruoyi-uinpm install –registry=https://registry.npmmirror.comnpm installmkdir /data/app/ruoyi-uimv dist/* /data/app/ruoyi-ui/ 配置nginx此处/代表根目录 root配置的dist的明确地址 /prod-api/配置的是转发路径，及前端请求都转发到 localhost:18081地址 ​ location / {​ root /data/app/ruoyi-ui/dist; 此处为前端dist路径​ index index.html index.htm;​ }​ location /prod-api/ { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://localhost:18081/; 此处为后端项目路径}重启nginx/data/service/ngnix/sbin/nginx -s reload访问 192.168.2..6:80","categories":[],"tags":[]},{"title":"","slug":"部署ruoyi前后端不分离版","date":"2022-08-18T08:51:40.113Z","updated":"2022-08-18T09:29:05.448Z","comments":true,"path":"2022/08/18/部署ruoyi前后端不分离版/","link":"","permalink":"http://example.com/2022/08/18/%E9%83%A8%E7%BD%B2ruoyi%E5%89%8D%E5%90%8E%E7%AB%AF%E4%B8%8D%E5%88%86%E7%A6%BB%E7%89%88/","excerpt":"","text":"部署ruoyi前后端不分离版项目目录 #tmp存放临时安装包mkdir -p /data/tmp#service存放软件环境mkdir -p /data/service#gitee存放代码版本控制库mkdir -p /data/gitee 安装javajavacd /data/tmptar -zxvf jdk-8u212-linux-x64.tar.gzmv jdk1.8.0_212 /data/servicecd /data/servicellvim /etc/profileexport JAVA_HOME=/data/service/jdk1.8.0_212export PATH=$PATH:$JAVA_HOME/binsource /etc/profile 安装mavencd /data/tmptar -zxvf apache-maven-3.8.5-bin.tar.gzmv apache-maven-3.8.5 /data/servicecd /data/servicellvim /etc/profileexport MAVEN_HOME=/data/service/apache-maven-3.8.5export PATH=$PATH:$MAVEN_HOME/binsource /etc/profilevim /data/service/apache-maven-3.8.5/conf/setting.xml#配置本地仓库/data/service/apache-maven-3.8.5/repository#配置阿里云镜像 aliyunmaven * 阿里云公共仓库 https://maven.aliyun.com/repository/public 安装gityum -y groupinstall “Development Tools”yum install wget unzip gettext-devel openssl-devel perl-CPAN perl-devel zlib-devel libcurl-devel expat-devel -ycd /data/tmptar zxvf git-2.18.0.tar.gzcd git-2.18.0./configure –prefix=/data/service/gitmake &amp;&amp; make installvim /etc/profileexport GIT_HOME=/data/service/gitexport PATH=$PATH:$GIT_HOME/binsource /etc/profile git公钥，和下载项目git密匙ssh-keygen -t rsa -C “&#49;&#53;&#x31;&#55;&#x32;&#x35;&#51;&#55;&#48;&#x34;&#57;&#64;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#109;“cat ~/.ssh/id_rsa.pub//粘到公匙ssh -T &#103;&#105;&#116;&#x40;&#x67;&#x69;&#116;&#x65;&#101;&#x2e;&#x63;&#111;&#x6d;cd /data/giteegit clone &#103;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#101;&#101;&#x2e;&#99;&#x6f;&#x6d;:y_project/RuoYi.git docker安装docker安装sudo yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-enginesudo yum install -y yum-utils device-mapper-persistent-data lvm2sudo yum-config-manager –add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repoyum install -y https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/edge/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpmyum install docker-ce docker-ce-cli -ysudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-‘EOF’{ “registry-mirrors”: [“https://plb9xzjh.mirror.aliyuncs.com&quot;]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker mysql安装docker pull mysql:5.7.30mkdir -p /root/mysql/data /root/mysql/logs /root/mysql/conftouch /root/mysql/conf/my.cnf//密码是admin，-v则是挂载 –name容器名字，作为后面的启动删除名字docker run -p 3306:3306 –rm –name mysql -v /root/mysql/conf:/etc/mysql/conf.d -v /root/mysql/logs:/var/log/mysql -v /root/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=admin -d mysql:5.7.30docker start mysql//进入容器docker exec -it mysql /bin/bash#登录docker容器（方式参考上方文档）后登录mysqlmysql -uroot -padmin#修改登录者的权限GRANT ALL ON . TO ‘root‘@’%’;#刷新命令生效 flush privileges; 修改项目配置cd /data/gitee/RuoYi/ruoyi-admin/src/main/resources/#修改application.yml的项目启动端口号与文件上传路径vim application.yml#修改application-druid.yml的数据源vim application-druid.yml 打包启动cd /data/gitee/RuoYi/mvn installmkdir -p /data/app/ruoyi-admincp /data/gitee/RuoYi/ruoyi-admin/target/ruoyi-admin.jar /data/app/ruoyi-admin/ruoyi-admin.jarcd /data/app/ruoyi-admin/#后台启动项目nohup java -jar ruoyi-admin.jar &amp;#查看项目运行日志tail -f nohup.out 开放端口重启防火墙firewall-cmd –permanent –add-port=80/tcpfirewall-cmd –reload","categories":[],"tags":[]},{"title":"","slug":"回溯，双指针，和栈的运用","date":"2022-07-25T02:59:38.180Z","updated":"2022-07-25T03:35:30.960Z","comments":true,"path":"2022/07/25/回溯，双指针，和栈的运用/","link":"","permalink":"http://example.com/2022/07/25/%E5%9B%9E%E6%BA%AF%EF%BC%8C%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%8C%E5%92%8C%E6%A0%88%E7%9A%84%E8%BF%90%E7%94%A8/","excerpt":"","text":"回溯，双指针，和栈的个人总结1.回溯给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1：输入：candidates = [2,3,6,7], target = 7, 个人思路总结常规回溯，回溯的下一次target为 target-candidates【i】，首先将数组排序，每次回溯时候，当target-candidate[i]&lt;0时候，则终止回溯，剪枝干。当target==0时候，则保留结果。注意结果不重复，则每次是以begin开始。 代码如下 2.双指针 给定n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 个人思路总结我们可以按照分列的思路解，遍历每一列，第一列，最后一列，不积水，跳过，第二列开始，每列积水高度由该列左边最高列，右边最高列中最短的列减去该列高度决定，如果该值小于零，则舍弃，大于零，则累加。 代码如下 3.栈的运用给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: “()” 输出: true 示例 2: 输入: “()[]{}” 输出: true 个人思路如果遇到左括号，则将右括号入栈。如果是右括号，则判断是不是和栈顶弹出的元素相同，如果不相同则false，如果相同则弹出，如果栈为空 则直接false，因为此时后面都是弹出的。 代码","categories":[],"tags":[]},{"title":"","slug":"算法-回溯总结","date":"2022-07-15T14:11:42.844Z","updated":"2022-07-15T14:18:56.333Z","comments":true,"path":"2022/07/15/算法-回溯总结/","link":"","permalink":"http://example.com/2022/07/15/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93/","excerpt":"","text":"回溯总结题目给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例:输入：”23”输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. 个人思路可以维护一个2-9对应字母的数组，为String[] numsString={“”, “”, “abc”, “def”, “ghi”, “jkl”, “mno”, “pqrs”, “tuv”, “wxyz”}; 则2-9分别有了对应关系，用dfs(String digits,int nums,String[] numsString)表示从下表nums开始回溯，则终止条件为nums==digits.length()，获取每个数字对应的temp，遍历temp，下标加一进行回溯，最后要移除最后一个字母 代码如下","categories":[],"tags":[]},{"title":"","slug":"算法-双指针和hashmap的运用","date":"2022-07-14T08:26:47.912Z","updated":"2022-07-14T08:53:08.827Z","comments":true,"path":"2022/07/14/算法-双指针和hashmap的运用/","link":"","permalink":"http://example.com/2022/07/14/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88%E5%92%8Chashmap%E7%9A%84%E8%BF%90%E7%94%A8/","excerpt":"","text":"算法-双指针和hashmap的运用1.两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 个人思路遍历数组，计算和目标的差额temp，并把数组放入hashmap，调用hashmap.put(nums[i],i)方法，如果hashmap中包含temp这个key，则是一种答案 2.最长回文子串给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 输入：s = “babad” 输出：”bab” 解释：”aba” 同样是符合题意的答案。 个人思路遍历字符串，每种i代表以什么为中心，分两种情况，一种是一个字符为中心朝两边扩展 ，如“bab”，中心是a，第二种是以两个字符为中心像两边扩展，如“baab”，中心是aa，创建extend（String s,int start,int end）方法，其中start，end方法代表字符截取的下标，如果s.chartAT(start)==s.chartAT(end)则start–，end++，最后返回最长的那个即是答案。 3.三数之和给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意： 答案中不可以包含重复的三元组。 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 个人思路遍历 字符串，i下表表示第一个数字索引，剩下两个两个数一个为i+1，一个为length-1，如果 nums【i】+nums【left】+nums【right】大于0，则 right–，否则left++；如果等于0，则right–，left++；另外等于0时候，则要考虑重复，如果这个 nums【right】==nums【right+1】则right–，就会去除重复","categories":[],"tags":[]},{"title":"","slug":"token的一点个人总结","date":"2022-07-08T15:12:08.053Z","updated":"2022-07-08T15:33:28.646Z","comments":true,"path":"2022/07/08/token的一点个人总结/","link":"","permalink":"http://example.com/2022/07/08/token%E7%9A%84%E4%B8%80%E7%82%B9%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/","excerpt":"","text":"token的个人总结token的组成1.header 元数据，定义token的类型和加密算法 2.payload token的具体数据，比如userid就是放在payload中 3.sign 签名 服务器通过Payload、Header和一个密钥(secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。 生成token方法调用 jwt.creat()方法生成，具体如下，先用SHA256算法将sercret加密，放入sign中，将userid放入payload中，定义header的加密算法和token类型 解析token方法，并获取userid主要是先根据sign获取到JWTVerifier对象，再获取DecodeJwt对象，最后将payload中uerid取出 总之，token是根据签名的加密算法生成sign，再根据sign反解析得到JWTVerifier，并可以把userid放入clamims中 token的一些好处1.无状态 2.有效避免了CSRF 攻击（大部分情况下存放在 local storage ）","categories":[],"tags":[]},{"title":"","slug":"Redis持久化机制","date":"2022-07-07T12:45:30.724Z","updated":"2022-07-07T12:49:04.246Z","comments":true,"path":"2022/07/07/Redis持久化机制/","link":"","permalink":"http://example.com/2022/07/07/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Redis 持久化机制很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。 Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。 快照（snapshotting）持久化（RDB） Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。 快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置： 12345save 900 1 #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。save 300 10 #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。save 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。 AOF（append-only file）持久化 与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启： 1appendonly yes 1 开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 server.aof_buf 中，然后再根据 appendfsync 配置来决定何时将其同步到硬盘中的 AOF 文件。 AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。 在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：appendfsync always #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度appendfsync everysec #每秒钟同步一次，显式地将多个写命令同步到硬盘appendfsync no #让操作系统决定何时进行同步","categories":[],"tags":[]},{"title":"","slug":"ThreadPoolExecutor 类分析","date":"2022-07-07T11:59:47.199Z","updated":"2022-07-07T12:25:56.716Z","comments":true,"path":"2022/07/07/ThreadPoolExecutor 类分析/","link":"","permalink":"http://example.com/2022/07/07/ThreadPoolExecutor%20%E7%B1%BB%E5%88%86%E6%9E%90/","excerpt":"","text":"线程池总结ThreadPoolExecutor 3 个最重要的参数： corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。 maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。 workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。 线程池的执行策略 线程池和callable一起使用，一般用来有返回值得类型第一 创建线程池 1private static ThreadPoolExecutor executorService = new ThreadPoolExecutor(9, 9, 1000, TimeUnit.MILLISECONDS, WORK_QUEUE, HANDLER); ​ 第二 重写callable方法 ​ Callable bannerListCallable = () -&gt; adService.queryIndex(); ​ 第三步 调用线程池submit方法，获取future对象 ​ Future banner=executorService.submit(bannerListCallable); ​ 第四步，调用future.get方法获取返回值 ​ Map&lt;String, Object&gt; entity = new HashMap&lt;&gt;(); ​ entity.put(“banner”, banner.get());","categories":[],"tags":[]},{"title":"","slug":"递归的一点思考","date":"2022-07-07T11:11:15.948Z","updated":"2022-07-07T12:26:34.949Z","comments":true,"path":"2022/07/07/递归的一点思考/","link":"","permalink":"http://example.com/2022/07/07/%E9%80%92%E5%BD%92%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/","excerpt":"","text":"递归的一点思考递归就是将大问题转化为小问题的一种思路。 它有两个特点， 1.重复调用自身函数 2.有终结条件 例如leetcode题目二叉树的中序遍历就可用递归","categories":[],"tags":[]},{"title":"","slug":"若依项目前后端分离部署","date":"2022-06-15T08:32:27.658Z","updated":"2022-07-07T12:27:57.561Z","comments":true,"path":"2022/06/15/若依项目前后端分离部署/","link":"","permalink":"http://example.com/2022/06/15/%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%83%A8%E7%BD%B2/","excerpt":"","text":"若依项目前后端分离部署启动防火墙 systemctl start firewalld 端口占用netstat -npl | grep “80” #开放端口 firewall-cmd –permanent –add-port=3306/tcp #重启防火墙firewall-cmd –reload #mysql安装docker pull mysql:5.7.30mkdir -p /root/mysql/data /root/mysql/logs /root/mysql/conftouch /root/mysql/conf/my.cnf//密码是admin，-v则是挂载 –name容器名字，作为后面的启动删除名字docker run -p 3306:3306 –rm –name mysql -v /root/mysql/conf:/etc/mysql/conf.d -v /root/mysql/logs:/var/log/mysql -v /root/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=admin -d mysql:5.7.30docker start mysql //进入容器docker exec -it mysql /bin/bash登录docker容器（方式参考上方文档)后登录mysqlmysql -uroot -padmin修改登录者的权限GRANT ALL ON . TO ‘root‘@’%’;#刷新命令生效 flush privileges; #重启mysql //docker rm mysqldocker run -p 3306:3306 –rm –name mysql -v /root/mysql/conf:/etc/mysql/conf.d -v /root/mysql/logs:/var/log/mysql -v /root/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=admin -d mysql:5.7.30重启redis//docker run -d –rm -v /root/redis/data:/data –name redis -p 6379:6379 redis redis-server –appendonly yes 重启nginx/data/service/ngnix/sbin/nginx -s reload 重启nginx // cd /data/tmpmake install/data/service/ngnix/sbin/nginx #Jenkins安装docker pull jenkinsci/blueoceandocker run –name jenkins -u root –rm -d -p 7005:8080 -p 50000:50000 -v /data/service/jenkins:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v /data/service/apache-maven-3.8.5:/usr/local/maven -v /data/service/jdk1.8.0_212:/usr/local/jdk jenkinsci/blueocean-u root：以 root 权限启动，防止出现权限问题-p 7005:8080：端口映射，服务器的 7005 端口映射容器的 8080 端口-p 50000:50000：Jenkins代理默认通过TCP端口50000与Jenkins主机通信-v /data/jenkins:/var/jenkins_home：把容器内的 Jenkins 目录挂载到服务器的 /data/jenkins 目录以防容器没了，数据也没了-v /var/run/docker.sock:/var/run/docker.sock：保证容器内的 docker 与 服务器上 docker 的通讯 附带下删除 jenkinsci/blueocean 容器 删除对应绑定网桥docker network disconnect –force bridge jenkinsci-blueocean 删除 jenkinsci-blueocean 容器，xxxx 容器 IDdocker rm -f xxxx查看密码 ，目录文件为/data/service/Jenkinscat /data/service/jenkins/secrets/initialAdminPasswordJenkisn部署项目 1.全局工作配置这里的java_home 路劲是docker挂载 路径，这里的maven路进是挂载路径注意：只用修改java和maven，git是已经有的2.插件安装搜索 Publish over SSH 插件安装，搜索 Maven Integration 插件安装3.ssh连接在系统设置下配置远程连接，这里我配置主机地址4.进入git项目配置 首先生成公钥进入jinkins容器后执行Docker exec -it dockerid bashssh-keygen -t rsa -C ‘&#x31;&#x35;&#x30;&#x31;&#x39;&#x34;&#55;&#x34;&#57;&#53;&#49;&#x40;&#49;&#54;&#x33;&#46;&#99;&#111;&#109;’cat ~/.ssh/id_rsa.pub将公钥粘入gitee 在安全认证中把公钥加入5，进入项目配置悬念则git仓库，选择刚才配置公钥 .选择6.选择ssh接入下面的shell如下cd /root/data/testid=$(ps -ef | grep “ruoyi-admin.jar” | grep -v grep| awk ‘{print $2}’)echo $idkill -9 $idnohup /data/service/jdk1.8.0_212/bin/java -jar ruoyi-admin.jar &gt;myout.log 2&gt;&amp;1 &amp;注意，这里一定要指定java执行路径 这里是/data/service/jdk1.8.0_212/bin/java，这是个大坑, 这里的远程目录是在/root下，即如果配置/data/test,则最终路径是在/root/data/test部署gitlabdocker pull gitlab/gitlab-cedocker run -d -p 443:443 -p 80:80 -p 222:22 –name gitlab –restart always -v /root/gitlab/config:/etc/gitlab -v /root/gitlab/logs:/var/log/gitlab -v /root/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce gitlab.rb文件内容默认全是注释$ vim /root/gitlab/config/gitlab.rb 配置http协议所使用的访问地址,不加端口号默认为80external_url ‘http://192.168.2.2&#39; 配置ssh协议所使用的访问地址和端口gitlab_rails[‘gitlab_ssh_host’] = ‘192.168.2.2 ‘gitlab_rails[‘gitlab_shell_ssh_port’] = 222 # 此端口是run时22端口映射的222端口:wq #保存配置文件并退出重启gitlab容器$ docker restart gitlab重置root密码docker exec -it gitlab（容器名字） /bin/bash启用docker里面gitlab的rubygitlab-rails console -e production 找到管理员用户user = User.where(id: 1).first 更改密码user.password = ‘abcd1234’user.password_confirmation = ‘abcd1234’记得保存user.save! webhook配置 安装Generic Webhook Trigger插件 加入git的公钥到jenkins 生成key ssh-keygen -t rsa -C ‘&#49;&#53;&#x31;&#x37;&#50;&#53;&#x33;&#55;&#x30;&#x34;&#x39;&#64;&#x31;&#54;&#x33;&#x2e;&#99;&#x6f;&#109;‘ cat ~/.ssh/id_rsa.pub 配置apitoken，这里是后面APItoken的地址6. 允许本地访问该地址 在menu-admin-setting-network7.8. 找到WebHooks配置界面，在POST地址框中输入如下格式内容：9.10. http://:@&lt;Jenkins IP地址&gt;:端口/generic-webhook-trigger/invoke11. 添加urlhttp://root:1148e42061461a8d68883794319c3dcd82@192.168.2.2:7005/generic-webhook-trigger/invoke 配置固定ip地址虚拟机安装Linux系列教材 （八）- 设置 Centos7 为固定ip地址 (how2j.cn)需要注意编写ens33时候 onboot=yes如果出现报错”Could not resolve host: mirrorlist.centos.org; Unknown error”则在”Could not resolve host: mirrorlist.centos.org; Unknown error”解决方法 - Mr.Gavin - 博客园 (cnblogs.com)处理 Ipv4转发（连接不上数据库）2.开启转发配置 vim /etc/sysctl.conf #配置转发net.ipv4.ip_forward=1#保存退出就可以了:wq!#重启服务，让配置生效systemctl restart network","categories":[],"tags":[]}],"categories":[],"tags":[]}